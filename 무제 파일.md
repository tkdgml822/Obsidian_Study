### 이항계수란

조합론에서 등장하는 개념으로 주어진 크기 집합에서 원하는 개수만큼 순서없이 뽑는 조합의 가짓수를 일컫는다.
2를 상징하는 "이항" 이라는 말이 붙은 이유는 하나의 아이템에 대해서는 **"뽑거나, 안뽑거나"** 두가지의 선택만이 있기 때문이다.

전체집합에서 원소의 개수 n에 대해 k개의 아이템을 뽑는 이항계수(조합의 수)는 다음과 같이 정의한다.

$$
1. \binom{n}{k} = nCk = \frac{n!}{(n-k)!k!}(단,0 \leq k \leq n )
$$

추가적으로 중요한 이항계수의 성질은 다음과 같다.

$$
2.\binom{n}{k}=\binom{n}{n-k}
$$

$$
3. \binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}
$$

$$
4. \sum_{k=0}^{n}\binom{n}{k} = 2^{n} 
$$

$$
5.\binom{n}{0}=\binom{n}{n}=1
$$

2번은 n개 중에서 k개를 선택하는 조합의 수와 선택받이 못한 나머지(n-k) 개를 선택하는 조합의 수와 같다.
3번은 파스칼의 항등식이다. 이후 동적 계획법의 점화식으로 사용한다. 밑에서 자세히 설명한다.
4번은 원소가 n개인 집합의 부분집합의 갯수는 2의n 제곱이다. n에 대한 모든 조합의 수를 다 합한것.
5번은 n개중 아무것도 고르지 않는 방법은 1가지이고, n개중 n개 모두를 선택하는 방법도 1가지 이다.

### 파스칼의 항등식

이항계수 nCk는 전체 대상이 n개일 때 대응된다. 이것과 대상이 하나 적은 n-1Ck 사이에 모종의 관계가 성립한다면 대상의 개수가 많아지더라도 먼저 구해놓은 결과를 이용해서 새로운 조합의 수를 구할 수 있게 된다.
예컨대 2Ck를 알고 있다면 그로부터 3Ck, 4Ck... 등을 기계적으로 계산할 수 있다는 것이다.
이처럼 앞의 결과로부터 다음 결과를 만들어 내는 것을 수학에서는 점화식이라고 하는데, 프로그래밍에서 어떤 함수가 스스로를 다시 호출하는 재귀와 일맥상통한다.

$$
3. \binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}
$$

구체적인 예를 가지고 파스칼의 항등식을 검토해본다.
카드 4장에 각각 A, K, Q, J 라는 글자가 적혀있다. 그중에서 2장을 고르는 경우의 수는 4C2 이다.
그러면 4C2와 3C2를 연관짓는 방법은 무엇인가?
일단 대상이 4개에서 3개로 하나 줄어야하므로 A라는 카드를 하나 제외하면 K, Q, J 총 3장이 남는다.

여기서 두 가지 가능성이 생긴다. 원래의 4장 중 2장을 고르려고 했을 때, 방금 제외된 A 카드가 고르려던 카드에
포함되었거나/포함되지 않았거나 두 가지 경우이다.

- A가 포함되지 않았다면: K, Q, J 중에서 2 장을 골라야 하므로 경우의 수는 3C2이다. 즉, n-1Ck
- A가 포함되었다면: K, Q, J 중에서 나머지 1 장만 고르면 되므로 경우의 수는 3C1이다. 즉, n-1Ck-1

이 두 가지는 동시에 일어날 수 없는 사건들이므로 전체 경우의 수는 두 결과의 합이 되어야 한다.

### 재귀함수를 이용한 해결방법

파스칼의 항등식을 이용해 하나의 식을 두 개의 작은 식으로 쪼갤 수 있고, 더 잘게 쪼개지면서 n과 k가 점점 작아지는데 k=0 또는 k=n이 되는 순간은 5번의 성질로 인해 1이 된다.
이것을 파이썬으로 구현한것은 다음과 같다.

```python
def binomial_coefficient(n, k):
    if k == 0 or n == k:
        return 1
    return binomial_coefficient(n - 1, k) + binomial_coefficient(n - 1, k - 1)

```

하지만 이 함수는 **부분문제의 중복**으로 인해 성능이 매우 나쁘다.
**부분문제의 중복**이라는 현상은 원 문제를 풀기 위해 문제를 부분적으로 나누었을때 이 부분문제들이 중복되는 현상을 말한다.이러한 현상을 해결하기 위해 **동적 계획법**이라는 방법이 생겼다.

### 동적 계획법(Dynamic Programming, DP)을 이용한 해결방법

동적 계획법은 이미 구한 부분문제의 답을 캐쉬에 저장해서 또 구해야 할 때 캐쉬에서 꺼내서 같은 문제를 풀지않는 방법이다.

원 문제 해결 중 마주치는 부분문제의 이항계수를 계산 후 캐쉬에 저장한다.
캐쉬는 2차원으로 만든다. 부분문제를 계산할 때 n은 0부터 n까지, k는 0부터 k까지의 범위를 지니기 때문에
(n+1) * (k+1) 사이즈로 캐쉬를 생성한다.
파이썬으로 구현한것은 다음과 같다.

```python
def binomial_coefficient(n, k):
    # 1.
    cache = [[0 for _ in range(k + 1)] for _ in range(n + 1)]

    # 2.
    for i in range(n + 1):
        cache[i][0] = 1
    for i in range(k + 1):
        cache[i][i] = 1

    # 3.
    for i in range(1, n + 1):
        for j in range(1, k + 1):
            cache[i][j] = cache[i - 1][j] + cache[i - 1][j - 1]

    return cache[n][k]

```

#1. 캐쉬를 (n+1) * (k+1) 사이즈로 만들고 0으로 초기화한다.
#2. 5번의 성질에 따라서 k=0 이거나 k=n일 경우 1이 된다.
#3. 파스칼의 항등식을 사용해 값을 구한다.