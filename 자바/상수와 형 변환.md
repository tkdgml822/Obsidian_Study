## 상수

상수는 ‘값이 변하지 않은 수’를 의미한다. 하지만 자바에서는 한번 그 값이 정해지면 이후로는 변경이 불가능한 변수도 상수라 한다.

- 자바의 일반적인 상수
    
    변수를 선언할 때 final이라는 선언을 추가하면 그 변수는 ‘상수’가 된다. 그리고 다음 두 가지 특징을 지니게 된다.
    
    - 값을 딱 한 번만 할당할 수 있다.
    - 한 번 할당된 값은 변경이 불가능하다.
    
    ```java
    class Constants {
    	public static void main(String[] args) {
    		final int MAX_SIZE = 100;
    		final char CONST_CHAR = '상';
    		final int CONST_ASSIGNED;
    		CONST_ASSIGNED = 12; // 할당하지 않았던 상수의 값 할당
    		System.out.println("상수1 : " + MAX_SIZE);
    		System.out.pritnln("상수2 : " + CONST_CHAR);
    		System.out.println("상수3 : " + CONST_ASSUGNED);
    	}
    }
    ```
    
    출력 값
    
    ```
    상수1 : 100
    상수2 : 상
    상수3 : 12
    ```
    
    상수를 선언만 하고 값을 할당하지 않으면 한 번은 값을 할당할 수 있다. 그러나 그 이후로는 역시 값의 변경이 불가능하다.
    
    관례상 상수의 이름은 다음 두 가지 사항을 지켜서 짓는다.
    
    - 상수의 이름은 모두 대문자를 짓는다.
    - 이름이 둘 이상의 단어로 이뤄질 경우 단어 사이에 언더바를 넣는다.
- 리터널(Literals)에 대한 이해
    
    다음 문장에서는 변수를 선언과 동시에 157이라는 값으로 초기화하였다. 이때 대입 연산자의 오른편에 위치한 숫자 157을 가리켜 ‘리터널’ 또는 ‘리터널 상수’라 한다.
    
    ```
    int num = 157;
    ```
    
    컴파일러는 위 문장에서 157를 무엇으로 인식하겠는가? int 정수로? 아니면 long형 정수로? 결론부터 말하면 숫자 157은 int형 정수로 인식한다. ”컴파일러는 숫자 157을 int형 정수로 인식한다. 그렇게 약속되어 있다.”
    
    자바의 정수 표현 방법에는 int와 long을 포함하여 네 가지가 있고, 실수의 표현 방법에는 float와 double 두 가지가 있다. 따라서 이렇듯 숫자를 접했을 때 이를 ‘무엇으로 인식할지에 대한 일종의 약속’이 필요하고, 이 약속에 근거하여 표현된 숫자를 가리켜 ‘리터널’ 또는 ‘리터널 상수’라 한다. 다음과 같은 궁금중이 있을 수도 있다. ”int num = 157에서 157이 int형인 이유는 num이 int형이기 때문 아닌가요?”
    
    그렇다면 다음 문장을 컴파일 해보자
    
    ```java
    long num = 3147483647; // 컴파일 오류 발생
    ```
    
    숫자 3147483647는 충분히 담을 수 있는데 오류가 난다.
    
    ```
    error: integer number too large: 3147483647
    ```
    
    “숫자 3147483647는 int형 정수이어야 하는데 값이 너무 크다!”
    
    즉 왼편에 있는 변수의 자료형에 상관없이 int형으로 표현하기로 약속되어있다.
    
- 정수형 상수의 표현 방법
    
    정수는 다음과 같이 8진수, 10진수, 16진수로 표현할 수 있다.
    
    - 10 진수로 int형 정수 표현
        
        int num = 11 + 22 + 33;
        
    - 8진수로 int형 정수 표현
        
        int num = 011 + 022 + 033;
        
    - 16진수로 int형 정수 표현: 숫자 앞에 0x 또는 0X 삽입
        
        int num = 0x11 + 0x22 + 0x33;
        
    
    그렇다면 byte형, short형 변수의 초기화는 어떻게 해야 할까? 다음과 같이 초기화할 수 있겠는가?
    
    byte num1 = 5;
    
    short num2 = 25;
    
    자바는 byte형과 short형 정수의 표현 방법을 제공하지 않기 때문에 위와 같은 초기화를 허용한다. 물론 각 자료형의 표현 범위를 넘어서는 정수로 초기화를 진행하는 경우에는 컴파일 오류가 발생한다. 반면에 long형 정수의 표현 방법은 별도로 제공한다. 따라서 long형 정수를 써야 하는 다음과 같은 경우는 컴파일러가 알아서 이를 long형으로 인식해주지 않는다.
    
    ```java
    System.out.println(3147483647 + 3147483648);
    ```
    
    숫자의 끝에 문자 L 또는 l을 붙이는 것이 long 정수의 표현 방법이니, 다음과 같이 문자를 작성해야 한다.
    
    ```java
    System.out.println(3147483647L + 3147483648L);
    ```
    
- 정수형 상수 관련 추가로 가능한 것들
    
    자바는 2진수로 표현하는 방법도 제공한다. 다음과 같이 2진수 표현 앞에 0B 또는 0b를 붙여서 표현하면된다.
    
    ```java
    byte seven = 0B111;
    int num205 = 0B11001101;
    ```
    
    그리고 단위 큰 수의 표현 및 인식에 도움을 주기 위해서 다음과 같이 중간에 언더바를 넣는 것도 허용하고 있다.
    
    ```java
    int num = 100_100_000;
    ```
    
    이 언더바는 넣고 싶은 곳에 얼마든지 넣을 수 있다.
    
- 실수형 상수
    
    실수를 표현하는 방법은 다음과 같다. 그리고 이런한 실수형 상수는 double형으로 인식된다.
    
    ```java
    double pi = 3.1415; // 3.1415는 실수형 상수
    ```
    
    따라서 다음과 같이 문장을 구성하면 두 double형 실수의 덧셈 결과를 확인할 수 있다.
    
    double형으로 표현된 상수임을 명시하고 싶다면, 이를 목적으로 다음과 같이 D 또는 d를 붙일 수 있다.
    
    ```java
    System.out.println(3.0004999D + 2.0004999D);
    ```
    
    float로 표현하고 싶으면 f 또는 F를 붙이면 된다. 하지만 계산오차가 나기 때문에 실수의 덧셈은 float형의 정밀도로 계산하기에는 적절하지 않다.
    
    ```java
    System.out.println(3.0004999F + 2.0004999F);
    ```
    
    다음과 같이 실수를 표현하는 것도 가능하다. 물론 이들은 double형 실수이다. 그리고 e를 대신해서 E를 넣어도 된다.
    
    $3.4e3$ → $3.4 * 10^3 = 3400.0$
    
    $3.4e-3$ → $3.4 * 10^-3 = 0.0034$
    
    위의 표현 방법으로 float형 실수를 표현하고 싶다면 다음과 같이 f 또는 F를 붙이면 된다.
    
    $3.4e3f$
    
    $3.4e-3f$
    
    그리고 다음의 상황에서는 앞 또는 뒤에 붙은 숫자 0을 생략할 수 있다.
    
    0.5 → .5
    
    7.0f → 7.f
    
- **부울형 상수와 문자형 상수**
    
    boolean형이 가질 수 있는 값은 다음 두 가지이다.
    
    true, false
    
    그리고 char형 변수를 설명하면서 문자를 다음과 같이 표현함을 보였는데, 이것이 문자형 상수의 표현 방법이다. ’한’ ‘글’ ‘A’ ‘Z’
    
    이외에도 ‘이스케이프 시퀀스(escapr sequences)’ 문자라는 것이 존재한다.
    
    ‘\b’ 백스페이스 문자
    
    ‘\t’ 탭 문자
    
    ‘\\’ 백슬래시 문자
    
    ‘\’’ 작은따옴표 문자
    
    ‘\”’ 큰따옴표 문자
    
    ‘\n’ 개 행 문자
    
    ‘\r’ 캐리지 리턴 문자
    
    이들 대부분은 문자가 아닌 화면상의 어떠한 현상을 나타내는 문자들이다. 예를 들어서 문자 \n은 행을 바꾸는 개 행의 의미로 사용된다.
    
    ‘\r’은 커서를 왼쪽 끝으로 이동시킨다.
    
    System.out.pritnln(”AB” + ‘\r’ + ‘C’);
    
    은 AB가 출력되고 왼쪽 끝에 커서가 이동한 후 C가 입력되기 때문에 CB가 출력이 된다.
    
    그리고 자바는 유니코드를 지원해주기 때문에 \u로 이용하면 특수문자를 출력할수 있다.
    
    ‘\u20AC’ 다음과 같이 \u에 이어서 16진수로 덧붙이면 해당 문자가 출력된다.
    

## 형 변환

우리의 관점에서는 1.0와 1은 같다. 하지만 자바의 관점에서는 서로 전혀 다른 값이다.

- 자료형의 변환이 의미하는 것은?
    
    만약에 다음과 같은 형식 있다면 어떻게 될까?
    
    ```java
    int num = 50;
    long num2 = 3147483647L;
    System.out.println(num1 + num2); // num1과 num2의 자료형이 다르다.
    ```
    
    이 상황에서는 int형 변수에 담긴 값을 long형으로 변환해야 데이터의 손실없이 연산이 가능하다. 따라서 다음의 과정을 거쳐서 연산을 마무리한다.
    
    - 변수 num1에 저장된 값을 long형으로 변환하여 메모리에 임시 저장한다.
    - 이어서 이 변환된 값과 num2에 저장된 값을 대상으로 덧셈을 진행한다.
    
    이러한 과정을 가리켜 ‘자료형 변환’ 또는 ‘형 변환’이라 한다.
    
- 자동 형 변환
    
    다음과 같은 규칙에 근거하여 자동으로 형 변환이 일어난다.
    
    - 규칙1: 자료형의 크기가 큰 방향으로 형 변환이 일어난다.
    - 규칙2: 자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.
    
    byte → short, char → int → long → float → double
    
    위의 그림에서 보이듯이 int형 데이터는 필요시 long, float, double형 데이터로 자동 형 변환된다.
    
    - 자동 형 변환의 예 1
    
    ```java
    double num1 = 30; // int형 정수 30은 double형으로 자동 형 변환
    ```
    
    - 자동 형 변환의 예 2
    
    ```java
    System.out.println(50L + 34.5); // long형 정수 59L은 double형으로 자동 형 변환
    ```
    
    참고로 형 변환의 규칙에서 크기에 상관없이 실수형이 정수형에 우선하는 이유는 정수형에 비해 실수형의 값의 표현 범위가 넓기 때문이다. 즉 정수형 데이터를 실수형으로 변환하면 데이터의 손실은 발생하지 않는다. 비록 오차가 존재한다.
    
- 명시적 형 변환
    
    자동 형 변환이 진행되지 않은 상황에서도 필요하다면 ‘명시적 형 변환’을 통해서 형 변환이 이뤄지도록 문장을 구성할 수 있다. 방법은 다음과 같다.
    
    ```java
    double pi = 3.1415;
    int wholeNumber = (int)pi; // pi값을 int형으로 명시적 형 변환
    ```
    
    하지만 wholeNumber에 저장되는 값은 3이다. 큰 정수 자료형애서 작은 정수 자료형으로 형 변환을 진행하는 경우 상위 바이트가 잘려나간다.
    
    그렇다면 언제 명시적 형 변환을 해야 할까? 다음과 같은 상황을 예를 들어보자
    
    ```java
    short num1 = 1;
    short num2 = 2;
    short num3 = num1 + num2; // 컴파일 오류 발생
    ```
    
    오류의 원인은 이렇다. 덧셈 연산을 위해서 num1과 num2에 저장된 값이 int형으로 변환되어 메모리에 임시 저장된다. 하지만 결과는 int형이라서 오류가 발생한다. 따라서 컴파일이 되기 위해서는 다음과 같이 변환을 해야한다.
    
    ```java
    short num3 = (short)(num1 + num2);
    ```