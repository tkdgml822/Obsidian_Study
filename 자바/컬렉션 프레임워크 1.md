## 컬렉션 프레임워크의 이해

- ‘프레임워크’라는 표현의 이해
    
    프레임워크는 다음의 의미를 공통적으로 지닌다.
    
    “잘 정의된 구조 또는 골격”
    
    따라서 자바에서 말하는 프레임워크는 다음과 같이 이해할 수 있다.
    
    “잘 정의된 구조의 클래스들”
    
    즉 프레임워크는 프로그래머들이 쓸 수 있도록 잘 정의된 클래스들의 모임이라 할 수 있다. 그런데 이것이 전부라면 ‘라이브러리’라 불리게 된다. 하지만 ‘컬렉션 라이브러리’라 하지 않고 ‘켈렉션 프레임워크’라 한다. 이는 컬렉션 관련된 클래스의 정의에 적용되는 설계 원칙 또는 구조가 존재하기 때문이이다.
    
- 컬렉션 프레임워크의 기본 골격
    
    ![https://blog.kakaocdn.net/dn/5x8kY/btqFkI7RILS/tQFVC0vhg8CS4eIzorgeAk/img.png](collect.png)
    

## List<E> 인터페이스를 구현하는 컬렉션 클래스들

- ArrayList<E> 클래스
    
    List<E> 인터페이스를 구현하는 대표적인 클래스 들은 다음과 같다.
    
    - ArrayList<E> → 배열 기반 자료구조, 배열을 이용하여 인스턴스 저장
    - LinkedList<E> → 리스트 기반 자료구조, 리스트를 구성하여 인스턴스 저장
    
    List<E> 인터페이스를 구현하는 컬렉션 클래스들이 갖는 공통적인 특성은 다음과 같다.
    
    - 인스턴스의 저장 순서를 유지한다.
    - 동일한 인스턴스의 중복 저장을 허용한다.
    
    ```java
	    import java.util.List;
	    import java.util.ArrayList;
	    
	    class ArrayListCollection {
	        public static void main(String[] args) {
	            List<String> list = new ArrayList<>();
	            
	            // 인스턴스 저장 
	            list.add("Toy");
	            list.add("Box");
	            list.add("Robot");
	    	
	            // 인스턴스 참조
	            for(int i = 0; i < list.size(); i++)
	                System.out.print(list.get(i) + '\\t');
	            System.out.println();
	    		
	            // 첫 번째 인스턴스 삭제
	            list.remove(0);
	       
	            // 삭제 후 인스턴스 참조
	            for(int i = 0; i < list.size(); i++)
	                System.out.print(list.get(i) + '\\t');
	            System.out.println();
	        }
	    }
    ```
    
    위 예제의 인스턴스 생성문은 다음과 같다.
    
    ```java
	    List<String> list = new ArrayList<>();
    ```
    
    이 문장에서 ArrayList<E>형 참조변수가 아닌 List<E>형 참조변수로 선언한 이유는 코드에 유연성을 제공하기 위함이다. 다음과 같이 컬렉션 클래스의 교체가 용이해진다.
    
    ```java
	    List<String> list = new ArrayList(); ->
	    List<String> list = new LinkedList<>();
    ```
    
    그리고 예제에서 보이는 인스턴스의 저장 방법은 다음과 같다.
    
    ```java
	    list.add("Toy"); // 인스턴스의 저장
    ```
    
    물론 실제 저장되는 것은 인스턴스의 참조 값이다. 이어서 , 인스턴스의 순차적 참조 방식은 다음과 같다.
    
    ```java
	    for (int i = 0; i < list.size(); i++) {
	    	System.out.println(list.get(i) + '\\t');
	    }
    ```
    
    첫 번째 인스턴스는 제일 먼저 저장된 인스턴스이다. 그리고 다음과 같이 인스턴스를 삭제할 수 도있다. 0을 전달하면 첫 번째로 저장된 인스턴스가 삭제된다.
    
    ```java
	    list.remove(0); // 맨 앞에 저장된(첫 번째로 저장된) 인스턴스 삭제
    ```
    
    ArrayList<E> 인스턴스는 내부적으로 배열로 구현이 되어있다. 그리고 필요하면 스스로 배열의 크기를 늘린다. 다음은 ArrayList<E>의 생성자이다.
    
    ```java
	    public ArrayList(int initialCapacity)
    ```
    
    → 인자로 전달된 수의 인스턴스를 저장할 수 있는 공간을 미리 확보
    
    저장해야알 인스턴스의 갯수가 대략 계산이 된다면 미리 적당한 길이를 만들어 두는 것이 성능 향상에 도움이 된다. 참고로 앞서 생성한 생성자는 다음과 같다.
    
    ```java
	    public ArrayList()
    ```
    
    → 10개의 인스턴스를 저장할 수 있는 공간을 미리 확보
    
- LinkedList<E> 클래스
    
    앞서 설명한 예제와의 차이점은 다음과 같다.
    
    ```java
	    List<String> list = new ArrayList<>(); ->
	    List<String> list = new LinkedList<>();
    ```
    
    ```java
	    import java.util.List;
	    import java.util.LinkedList;
	    
	    class LinkedListCollection {
	        public static void main(String[] args) {
	            List<String> list = new LinkedList<>();
	            
	            // 인스턴스 저장 
	            list.add("Toy");
	            list.add("Box");
	            list.add("Robot");
	    	
	            // 인스턴스 참조
	            for(int i = 0; i < list.size(); i++)
	                System.out.print(list.get(i) + '\\t');
	            System.out.println();
	    		
	            // 첫 번째 인스턴스 삭제
	            list.remove(0);
	       
	            // 삭제 후 인스턴스 참조
	            for(int i = 0; i < list.size(); i++)
	                System.out.print(list.get(i) + '\\t');
	            System.out.println();
	        }
	    }
    ```
    
    LinkedList<E>는 ‘연결 리스트(Linked List)’라는 자료구조의 기반으로 디자인된 클래스이다. 그런데 연결 리슽라는 것은 ‘칸캍이 연결된 열차’를 생각하면 된다. 따라서 인스턴스의 저장 및 삭제는 다음과 같은 방식으로 진행된다.
    
    - 인스턴스 저장 - 열차 칸 하나 추가로 연결하고, 그 열차 칸에 인스턴스를 저장한다.
    - 인스턴스 삭제 - 해당 인스턴스를 저장하고 있는 열차 칸을 삭제한다.
- ArrayList<E> vs LinkedList<E>
    
    ArrayList<E>의 단점
    
    - 저장공간을 늘리는 과정에서 시간이 비교적 많이 소요된다.
    - 인스턴스의 삭제 과정에서 많은 연산이 필요할 수 있다. 따라서 느릴 수 있다.
    
    배열 중간에 있는 인스턴스를 삭제할 경우, 삭제된 위치를 비워 두지 않기 위해서 그 뒤에 저장되어 있는 값들을 전부 한칸 옮기기 때문에 삭제 과정에서 많은 연산이 필요할 수 있다.
    
    ![이런씩으로 배열형식으로 구현이 되어 있기 때문에 중간에 하나의 값이 삭제가된면 뒤에 데이터들을 전부 한칸씩 옮기는 많은 과정이 필요하다.](arraylist.png)
    
    이런씩으로 배열형식으로 구현이 되어 있기 때문에 중간에 하나의 값이 삭제가된면 뒤에 데이터들을 전부 한칸씩 옮기는 많은 과정이 필요하다.
    
    ArrayList<E> 장점
    
    - 저장된 인스턴스의 참조가 빠르다.
    
    배열에 저장되어 있기 때문에 인덱스 값을 통해서 바로 접근이 가능하기 때문에 소유시간이 똑같다. 하지만 LinkedList<E>는 이러한 접근이 불가능하다.
    
    LinkedList<E>의 단점
    
    - 저장된 인스턴스의 참조 과정이 배열에 비해 복잡하다. 따라서 느릴 수 있다.
    
    링크드 리스트는 중간에 있는 값에 바로 접근이 불가능하다. 값의 첫번째 또는 마지막 부분으로 접근을 해야한다. 열차로 비교하면 열차에서 탈수 있는 입구가 맨앞이랑 맨뒤만 있는 것이다. 따라서 참조 속도가 느리다.
    
    ![https://lemidia.github.io/assets/images/Linkedlist4.png](linkedList.png)
    
    LinkedList<E>의 장점
    
    - 저장 공간을 늘리는 과정이 간단하다.
    - 저장된 인스턴스의 삭제 과정이 단순하다.
    
    링크드 리스트의 내부에는 다음 노드(Node)를 가르키는 즉 다음 값을 가르키는 참조 값이 있다. 만약 삭제가 이뤄진다면 삭제가 이뤄지는 전 노드와 다음 노드를 이어주면 된다. 열차와 비교하면 열차의 칸마다 연결고리가 있는데 중간에 있는 열차에 이상이 있어 수리를 해야해서 빼야된다고 하면 열결고리 끊는 것이다.
    
- 저장된 인스턴스의 순차적 접근 방법1 : enhanced for문의 사용
    
    “저장된 모든 인스턴스들에 순차적으로 접근”
    
    특정 인스턴스를 찾아야 할때, 저장된 인스턴스 전부를 대상으로 탐색을 해야 한다 쉽게 말해서 하나씩 꺼내 보아야 한다. 이때 for문도 있지만 for-each문을 사용하는 것이다. (물론 탐색 알고리즘을 쓰면 쉽지만 이 책은 알고리즘 서적이 아니라서 다루지 않는다.)
    
    ```java
    import java.util.List;
    import java.util.LinkedList;
    
    class EnhancedForCollection {
        public static void main(String[] args) {
            List<String> list = new LinkedList<>();
            
            // 인스턴스 저장 
            list.add("Toy");
            list.add("Box");
            list.add("Robot");
    	
            // 인스턴스 참조
            for(String s : list)
                System.out.print(s + '\\t');
            System.out.println();
    		
            // 첫 번째 인스턴스 삭제
            list.remove(0);
       
            // 삭제 후 인스턴스 참조
            for(String s : list)
                System.out.print(s + '\\t');
            System.out.println();
        }
    }
    ```
    
    다음과 같이 for-each문을 사용할 수 있다.
    
    ```java
    for (String s : list) {
    	System.out.println(s + '\\t');
    }
    ```
    
    위 문장은 배열을 대상으로 하는 for-each문과 사실상 차이가 없다. 하지만 for-each문을 통한 순차적 접근의 대상이 되려면, 다음 인터페이스를 구현을 해야한다. ('순차적 접근'은 데이터 구조의 요소를 한 번에 하나씩, 순서대로 접근하는 것을 의미합니다. 즉, 데이터의 처음부터 끝까지 순서대로 각 요소에 접근하는 것을 말합니다.)
    
    그리고 ArrayList<E>, LinkedList<E> 클래스들은 위의 인터페이스를 구현하고 있다. 정확히는 다음과 같이 Collection<E>가 Iterable<T>를 상속하는데, ArrayList<E>, LinkedList<E> 클래스는 Collection<E> 인터페이스를 구현하고 있다.
    
    ```java
    public interface Collection<E> extends Iterable<E>
    ```
    
    Iterable<E>는 직접 혹은 간접적으로 구현하는 클래스의 인스턴스 대상으로 for-each문을 구성할 수 있다.
    
- 저장된 인스턴스의 순차적 접근 방법2
    
    Interable<T>를 상속한다고 했다. Collection<E>를 구현하는 자바의 제네릭 클래스는 Iterable<T>의 다음 추상 메소드를 모두 구현한다.
    
    ```java
    Iterable<T> iterable()
    ```
    
    이 메소드는 ‘반복자(Iterable)’라는 것을 반환한다. 반복자는 저장된 인스턴스들을 순차적으로 참조 할 때 사용하는 인스턴스로, 일종의 ‘지팡이’에 비유할 수 있다. 그리고 이 지팡이를 얻는 방법은 다음과 같다.
    
    ```java
    public static void main(String[] args) {
    	List<String> list = new LinkedList<>();
    	....
    	Iterable<String> itr = list.iterator(); // 반복자 획득, itr이 지팡이를 참조한다.
    }
    ```
    
    Iterator<E>의 메소드들은 다음과 같다.
    
    - E next() - 다음 인스턴스의 참조 값을 반환
    - boolean hasNext() - next 메소드 호출 시 참조 값 반환 가능 여부 확인
    - void remove() - next 메소드 호출을 통해 반환했던 인스턴스 삭제
    
    반복자 next호출 할 떄마다 첫 번째 인스턴스를 시작으로 다음 인스턴스의 참조 값을 차례로 반환한다. 그리고 더 이상 반환 값이 없을 때는 NoSuchElementException 예외를 발생시킨다. 그래서 다음과 같이 반복문을 구성해야 한다.
    
    ```java
    while (itr.hasNext()) { // next 메소드가 반환할 대상이 있다면,
    	str = irt.next();     // next 메소드를 호출한다.
    	....
    }
    ```
    
    hasNext는 반활할 대상이 있는지르 미리 확이하는 메소드이다. 그리고 for-each문과 달리 중간에 특정 인스턴스를 삭제하는 것이 가능하다.
    
    ```java
    while (itr.hasNext()) {
    	str = itr.next();
    	if (str.equals("Box")) {
    		itr.remove(); // 위에서 next 메소드가 반환한 인스턴스 삭제
    }
    ```
    
    반복자를 원하는 때에 다시 첫 번째 인스턴스에 가리키게 하려면 어떻게 해야 할까? 다음과 같이 반복자를 얻어야 한다.
    
    ```java
    Iterator<String> itr = list.iterator();
    ```
    
    ```java
    import java.util.List;
    import java.util.LinkedList;
    import java.util.Iterator;
    
    class IteratorCollection {
        public static void main(String[] args) {
            List<String> list = new LinkedList<>();
            
            // 인스턴스 저장 
            list.add("Toy");  list.add("Box");
            list.add("Robot");  list.add("Box");
    	
            // 반복자 획득
            Iterator<String> itr = list.iterator();
            
            // 반복자를 이용한 순차적 참조
            while(itr.hasNext())
                System.out.print(itr.next() + '\\t');
    
            System.out.println();
            
            // 반복자 다시 획득
            itr = list.iterator();
                    		
            // "Box"의 삭제 
            String str;
            while(itr.hasNext()) {
                str = itr.next();
                
                if(str.equals("Box"))
                    itr.remove();
            }
        
            // 반복자 다시 획득
            itr = list.iterator();
            
            // 삭제 후 결과 확인
            while(itr.hasNext())
                System.out.print(itr.next() + '\\t');
    
            System.out.println();
        }
    }
    ```
    
    참고로 for-each반복문도,
    
    ```java
    for (String s : list)
    	System.out.println(s + '\\t');
    ```
    
    컴파일 과정에서 다음과 같이 반복자를 이용하는 코드로 수정된다. 즉 for-each문 역시 반복자에 의해 순차적으로 접근으로 진행이 된다.
    
    ```java
    for (Iterator<String> itr = list.iterator(); itr.hasNext(); )
    	Ststem.out.println(itr.next() + '\\t');
    ```
    
- 배열보다는 컬렉션 인스턴가 좋다. : 컬렉션 변환
    
    배열과 ArrayList<E>는 특성이 유사하다. 그런데 대부분의 경우 배열보다 ArrayList<E>가 더 좋다. 첫 번째 이유는 인스턴스의 저장과 삭제가 편하다. 그리고 두 번째 이유로 ‘반복자’를 쓸 수 있다. 단 배열처럼 ‘선언과 동시에 초기화’를 할 수 없어서 초기에 무엇인가를 채원 넣는 일지 조금 번거롭다. 하지만 다음과 같이 컬렉션 인스턴스를 생성할 수 있어서 이것도 문제가 되지 않는다.
    
    ```java
    List<String> list = Arrays.asList("Toy", "Robot", "Box");
    ```
    
    → 인자로 전달된 인스턴스들을 저장된 컬렉션 인스턴스의 생성 및 반환
    
    그런데 이렇게 생성된 컬렉션 인스턴스는 새로운 인스턴스의 추가로 삭제가 불가능하다. 물론 반복자의 생성은 가능하나 이를 통해서 참조만 가능할 뿐이다. 따라서 새로운 인스턴스의 추가나 삭제가 필요한 상황이라면 다음 생성자를 기반으로 ArrayList<E> 인스턴스를 생성해야 한다.
    
    ```java
    class ArrayList<E> {
    	public ArrayList(Collection<? extend E> c) {...} // 생성자
    	...
    }
    ```
    
    이 생성자는 <? extends E>로 구현이 되어 있다. ‘읽기’만 가능하고 ‘쓰기’는 불가능하다.
    
    ```java
    public ArrayList(Collection<E> c)
    ```
    
    → Collection<E>를 구현한 컬렉션 인스턴스를 인자로 전달 받는다.
    
    → E는 생성 과정에서 무엇이든 될 수 있다.
    
    → 매개변수 c로 전달된 컬렉션 인스턴스에서는 참조만(꺼내기만) 가능하다.
    
    ```java
    public static void main(String[] args) {
    	// List<E>는 collection<E>를 상속한다.
    	List<String> list = Arrays.asList("Toy", "Box", "Robot", "Box");
    
    	// 생성자 public ArrayList(Collection<? extedns E> c)를 통한 인스턴스 생성
    	list = new ArrayList<>(list);
    	....
    }
    ```
    
    대다수 컬렉셕 클래스들은 다른 컬렉션 인스턴스를 인자로 전달받는 생성자를 가지고 있다.
    
    ```java
    public ArrayList(Collection<? extends E> c) // ArrayList<E> 생성자 중 하나
    ```
    
    ```java
    public LikedList(Collection<? extends E> c) // LikedList<E> 생성자 중 하나
    ```
    
    ```java
    public HashSet(Collection<? extends E> c) // HashSet<E> 생성자 중 하나
    ```
    
    따라서 ArrayList<E> 인스턴스를 사용하다가 연결 리스트 자료구조의 특성이 필요하다면 다음 예제에서 보이는 바와 같이 이를 기반으로 LinkedList<E> 인스턴스를 생성하면 된다.
    
    ```java
    import java.util.List;
    import java.util.ArrayList;
    import java.util.LinkedList;
    import java.util.Iterator;
    import java.util.Arrays;
    
    class ConversionCollection {
        public static void main(String[] args) {
            List<String> list = Arrays.asList("Toy", "Box", "Robot", "Box");
            list = new ArrayList<>(list);
    
            // ArrayList<E> 인스턴스의 순환
            for(Iterator<String> itr = list.iterator(); itr.hasNext(); )
                System.out.print(itr.next() + '\\t');
            System.out.println();
    
            // ArrayList<E>를 LinkedList<E>로 변환
            list = new LinkedList<>(list);
    
            // LinkedList<E> 인스턴스의 순환
            for(Iterator<String> itr = list.iterator(); itr.hasNext(); )
                System.out.print(itr.next() + '\\t');
            System.out.println();
        }
    }
    ```
    
- 기본 자료형 데이터의 저장과 참고
    
    컬렉션 인스턴스도 기본 자료형을 저장하지 못한다. 그러나 래퍼 클래스의 도움으로 이들 값의 저장 및 참조가 가능하다. 이 과정에서 오토 박싱과 오토 언박싱으로 인해 자연스로운 코드의 구성이 가능하다.
    
    ```java
    import java.util.Iterator;
    import java.util.LinkedList;
    
    class PrimitiveCollection {
        public static void main(String[] args) {
            LinkedList<Integer> list = new LinkedList<>();
    
            // 저장 과정에서 오토 박싱
            list.add(10);	
    				list.add(20);		
    				list.add(30);	
        
            int n;
            for(Iterator<Integer> itr = list.iterator(); itr.hasNext(); ) {
                n = itr.next();    // 오토 언박싱
                System.out.print(n + "\\t");
            }
    
            System.out.println();
        }
    }
    ```
    
- 연결 리스트만 갖는 양방향 반복자
    
    Collection<E>를 구현하는 클래스의 인스턴스는 iterator 메소드의 호출을 통해서 ‘반복자’를 얻을 수 있다. 그런데 List<E>를 구현하는 클래스의 인스턴스들만 얻을 수 있는 ‘양방향 반복자’라는 것이 있는데, 이는 List<E>의 다음 메소드에서 얻을 수 있다.
    
    ```java
    public ListIterator<E> listIterator()
    -> ListIterator<E>는 Iterator<E>을 상속한다.
    ```
    
    위의 메소드가 반환하는 반복자는 양쪽 방향으로 이동이 가능하다. 이는 배열이나 연결 리스트와 같은 자료구조의 특성상 가능한 일이다.
    
    E next() - 다음 인스턴스의 참조 값을 반환
    
    boolean hasNext() - next 메소드 호출 시 참조 값 반환 가능 여부 확인
    
    void remove() - next 메소드 호출을 통해 반환했던 인스턴스를 삭제
    
    E previous() - next 메소드와 기능은 같고 방향만 반대
    
    boolean hasPrevious() - hasnext 메소드와 기능은 같고 방향만 반대
    
    void add(E e) - 인스턴스 추가
    
    void set(E e) - 인스턴스 변경
    
    ListIterator<E>는 Iterator<E>를 상속하기 때문에 next, hasNext, remove는 이미 설명한 메소드와 같다. 다음은 양방향 반복자의 사용의 예를 보이겠다.
    
    ```java
    import java.util.List;
    import java.util.ArrayList;
    import java.util.Iterator;
    import java.util.ListIterator;
    import java.util.Arrays;
    
    class ListIteratorCollection {
        public static void main(String[] args) {
            List<String> list = Arrays.asList("Toy", "Box", "Robot", "Box");
            list = new ArrayList<>(list);
           
            ListIterator<String> litr = list.listIterator();
            String str; 
    
            // 왼쪽에서 오른쪽으로 
            while(litr.hasNext()) {
                str = litr.next();
                System.out.print(str + '\\t');
    
                if(str.equals("Toy"))
                    litr.add("Toy2");
            }
            System.out.println();
            
            // 오른쪽에서 왼쪽으로
    
            while(litr.hasPrevious()) {
                str = litr.previous();
                System.out.print(str + '\\t');
    
                if(str.equals("Robot"))
                    litr.add("Robot2");
            }
            System.out.println();
    
            // 다시 왼쪽에서 오른쪽으로
            for(Iterator<String> itr = list.iterator(); itr.hasNext(); )
                System.out.print(itr.next() + '\\t');
            System.out.println();
        }
    }
    ```
    
    ```java
    Toy Box   Robot  Box
    Box Robot Robot2 Box    Toy2  Toy
    Toy Toy2  Box    Robot2 Robot Box
    ```
    
    “next 호출 후에 add 호출하면, 앞서 반환된 인스턴스 뒤에 새 인스턴스 삽이된다.”
    
    “previous 호출 후에 add 호출하면, 앞서 반환된 인스턴스 앞에 새 인스턴스 삽입된다.”
    

## Set<E> 인터페이스를 구현하는 컬렉션 클래스들

- Set<E>을 구현하는 클래스의 특징과 HashSet<E> 클래스들
    
    Set<E> 인터페이스를 구현하는 제네릭 클래스의 특성 구 가지를 정리하면 다음과 같다.
    
    - 저장 순서가 유지되지 않는다.
    - 데이터의 중복 저장을 허용하지 않는다.
    
    Set<E>은 순서도 유지되지 않고 중복도 허용하지 않는다. 그리고 Set의 특징은 수학의 ‘집합’의 특성이다.
    
    ```java
    import java.util.Iterator;
    import java.util.HashSet;
    import java.util.Set;
    
    class SetCollectionFeature {
        public static void main(String[] args) {
            Set<String> set = new HashSet<>();
            set.add("Toy");
    				set.add("Box");
    				set.add("Robot");
    				set.add("Box");
    			        
            System.out.println("인스턴스 수: " + set.size());
    		
            for(Iterator<String> itr = set.iterator(); itr.hasNext(); )
                System.out.print(itr.next() + '\\t');
            System.out.println();
    
            for(String s : set)
                System.out.print(s + '\\t');
            System.out.println();
        }
    }
    ```
    
    ```java
    Box Robot Toy
    Box Robot Toy
    ```
    
    동일한 데이터로 판단하는 기준은 무엇일까?
    
    ```java
    import java.util.HashSet;
    
    class Num {
        private int num;
        
        public Num(int n) {
            num = n;
        }
    
        @Override
        public String toString() {
            return String.valueOf(num);
        }
    }
    
    class HashSetEqualityOne {
        public static void main(String[] args) {    
            HashSet<Num> set = new HashSet<>();
            set.add(new Num(7799));
            set.add(new Num(9955));
            set.add(new Num(7799));
    
            System.out.println("인스턴스 수: " + set.size());
    
            for(Num n : set)
                System.out.print(n.toString() + '\\t');
    
            System.out.println();
        }
    }
    ```
    
    ```java
    7799 7799 9955
    ```
    
    하지만 지니고 있는 값이 같지만 ‘7799’는 두번 나왔다. 이는 HashSet<E>이 판단하는 동일 인스턴스의 기준은, Object 클래스에 정의되어 있는 두 메소드의 호출 결괄를 근거로 하기 때문이다.
    
    ```java
    public boolean equals(Object obj)
    public int hashCode()
    ```
    
- 해쉬 알고리즘과 hashCode 메소드
    
    다음 숫자들이 있다고 해보자
    
    ```java
    3, 5, 7, 12, 25, 31
    ```
    
    이 숫자들을 num이라는 변수에 하나씩 넣어서 연산한다고 해보자 다음 연산씩은 다음과 같다.
    
    ```java
    num % 3
    ```
    
    이러면 나머지 연산의 결과 0과 1그리고 2를 기준으로 세가지 분류가 나눠진다.
    
    연산결과 0: 3, 12
    
    연산결과 1: 7, 31, 25
    
    연산결과 2: 5
    
    이렇게 3개의 분류로 나뉜 상태가 된다. 여기서 정수 5를 찾는다고 해보자. 하나씩 찾는거 보다. 연산결과가 2인 연산을 찾는것이 효율적이다. 즉 탐색 대상을 줄여버리는 것이다. 이것이 해쉬 알고리즘을 쓰는 이유다. 다음과 같은 과정을 거치기 때문에 탐색 속도가 빠르다.
    
    - 탐색 1단계 - 정수 5의 해쉬 값을 계산하여 탐색 부류를 결정
    - 탐색 2단계 - 선택된 부류 내에 정수 5가 존재하는지 확인
    
    그리고 위의 두 단계를 거쳐서 동일 인스턴스의 존재 여부를 확인하는 클래스가 HashSet<E>이다. 즉 이 클래스의 탐색 과정은 다음과 같다.
    
    - 탐색 1단계: Object 클래스에 정의된 hashCode 메소드의 반환 값을 기반으로 부류 가능
    - 탐색 2단계: 선택된 부류 내에서 equals 메소드를 호출하여 동등 비교
    
    앞에 있는 예제는 왜 비교가 안된이유
    
    “인스턴스가 다르면 Object 클래스의 hashCode 메소드는 다른 값을 반환한다.”
    
    “인스턴스가 다르면 Object 클래스의 equals 메소드는 false를 반환한다.”
    
    동등 여부를 따르게 할려면 다음과 같이 두 메소드를 오버라이딩 해야한다.
    
    ```java
    import java.util.HashSet;
    
    class Num {
        private int num;
        
        public Num(int n) {
            num = n;
        }
    
        @Override
        public String toString() {
            return String.valueOf(num);
        }
    
        @Override
        public int hashCode() {
            return num % 3;
        }
    
        @Override
        public boolean equals(Object obj) {
            if(num == ((Num)obj).num)
                return true;
            else
                return false;
        }    
    }
    
    class HashSetEqualityTwo {
        public static void main(String[] args) {    
            HashSet<Num> set = new HashSet<>();
            set.add(new Num(7799));
            set.add(new Num(9955));
            set.add(new Num(7799));
    
            System.out.println("인스턴스 수: " + set.size());
    
            for(Num n : set)
                System.out.print(n.toString() + '\\t');
    
            System.out.println();
        }
    }
    ```
    
- hashCode 메소드의 다양한 정의
    
    ```java
    import java.util.HashSet;
    
    class Car {
        private String model;
        private String color;
        
        public Car(String m, String c) {
            model = m;
            color = c;
        }
    
        @Override
        public String toString() {
            return model + " : " + color;
        }
    
        @Override
        public int hashCode() {
            return (model.hashCode() + color.hashCode()) / 2;
        }
    /*
        @Override
        public int hashCode() {
            return java.util.Objects.hash(model, color);
        }
    */
        @Override
        public boolean equals(Object obj) {
            String m = ((Car)obj).model;
            String c = ((Car)obj).color;
    
            if(model.equals(m) && color.equals(c))
                return true;
            else
                return false;
        }    
    }
    
    class HowHashCode{
        public static void main(String[] args) {    
            HashSet<Car> set = new HashSet<>();
            set.add(new Car("HY_MD_301", "RED"));
            set.add(new Car("HY_MD_301", "BLACK"));
            set.add(new Car("HY_MD_302", "RED"));
            set.add(new Car("HY_MD_302", "WHITE"));
            set.add(new Car("HY_MD_301", "BLACK"));
    
            System.out.println("인스턴스 수: " + set.size());
    
            for(Car car : set)
                System.out.println(car.toString() + '\\t');
        }
    }
    ```
    
    이렇듯 두개의 참조변수로 해쉬 코드를 오버라이딩하는 방법이다. 하지만 이렇듯 hashCode 메소드를 정의하는 것은 번거로운 일이다. 그래서 자바는 다음 메소드를 호출 해주고 있다.
    
    ```java
    public static int hash(Object..values)
    -> java.util.Objects에 정의된 메소드, 전달된 인자 기반의 해쉬 값 반환
    ```
    
    위에 매개변수에는 ‘가변 인자 선언’이 포함되어 있는데, 이를 전달되는 인자의 수를 메소드 호출 시마다 달리 할 수 있는 선언이다.(chaper 25에서 나옴)
    
    ```java
    @Override
    public int haschCode() {
    	return Object.hash(model, color); // 전달인자 model, color 기반 해쉬 값 반환
    }
    ```
    
    이렇듯 hash 메소드는 하나 이상의 인자를 조합하고 하나의 해쉬 값을 만들어 반환한다. 따라서 특별한 경우가 아니라면 직접 해쉬 알고리즘을 만들지 않고 이 메소드를 의존해도 된다.
    
- TreeSet<E> 클래스의 이해와 활용
    
    Set<E> 인터페이스를 구현하는 TreeSet<E> 클래스를 소개하고자 한다. TreeSet<E> 클래스는 ‘트리(Tree)’라는 자료구조를 기반으로 인스턴스를 저장한다. 그리고 이는 정렬된 상태가 유지되면서 인스턴스가 저장된다.
    
    ```java
    import java.util.TreeSet;
    import java.util.Iterator;
    
    class SortedTreeSet {
        public static void main(String[] args) {
            TreeSet<Integer> tree = new TreeSet<Integer>();
            tree.add(3); tree.add(1);
            tree.add(2); tree.add(4);
    
            System.out.println("인스턴스 수: " + tree.size());
            
            // for-each문에 의한 반복
            for(Integer n : tree)
                System.out.print(n.toString() + '\\t');
            System.out.println();
    
            // Iterator 반복자에 의한 반복
            for(Iterator<Integer> itr = tree.iterator(); itr.hasNext(); )
                System.out.print(itr.next().toString() + '\\t');
            System.out.println();
        }
    }
    ```
    
    ```java
    1 2 3 4
    1 2 3 4
    ```
    
    이렇듯 TreeSet<E> 인스턴스가 정렬 상태를 유지하면서 인스턴스를 저장하기 때문에 TreeSet<E>의 반복지는 다음의 특징을 갖는다.
    
    “인스턴스들의 참조 순서는 오름차순을 기준으로 한다.”
    
    그리고 이러한 특징은 위의 실행 결과를 통해서 확인할 수 있다. 하지만 크고 작음에 대한 기준은 프로그래머가 결정할 일이다. 그래서 위와 같이 클래스를 정의할 때에는 다음 인터페이스의 구현을 통해서 크고 작은에 대한 기준을 정해주어야 한다.
    
    ```java
    public interface Comparalbe<T>
    -> 이 인터페이스에 위치한 유일한 추상 메소드 int compareTo(T o)
    ```
    
- 인스턴스의 비교 기준을 정의하는 Comparable<T> 인터페이스의 구현 기준
    
    Comparable<T> 인터페이스를 구현할 때 정의해야 할 추상 메소드는 다음과 같다.
    
    ```java
    int comareTo(T o)
    ```
    
    그리고 이 메소드의 정의 방법은 다음과 같으면, 이는 자바에서 결정한 일정의 약속이다.
    
    - 인자로 전달된 o가 작다면 양의 정수 반환
    - 인자로 전달된 o가 크다면 음의 정수 반환
    - 인자로 전달된 o가 같다면 0을 반환
    
    다음은 Person 클래스가 나이를 기준으로 정렬되도록 compareTo 메소드의 구현 결과를 보이겠다. 정렬 기준은 다음과 같다. 나이가 적으면 적은것이고 나이가 많으면 큰 것이다.
    
    ```java
    import java.util.TreeSet;
    import java.util.Iterator;
    
    class Person implements Comparable<Person> {
        private String name;
        private int age;
    
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        @Override
        public String toString() {
            return name + " : " + age;
        }
    
        @Override
        public int compareTo(Person p) {
            return this.age - p.age;
        }
    }
    
    class ComparablePerson {
        public static void main(String[] args) {
            TreeSet<Person> tree = new TreeSet<>();
            tree.add(new Person("YOON", 37));
            tree.add(new Person("HONG", 53));
            tree.add(new Person("PARK", 22));
    	
            for(Person p : tree)
                System.out.println(p);
        }
    }
    ```
    
    ```java
    class PersonComparator implements Comparator<Person> {
        public int compare(Person p1, Person p2) {
            return p2.age - p1.age; 
        }
    }
    
    ```
    
    위 예제 처럼 이제 크고 작은에 대한 기준을 직접 결정하고 이를 반영할 수 있게 되었다. 줄을 세울 때 나이 많으신 분들을 우대하고 줄 앞쪽에 위치하도록 하려면 위의 메소드를 다음과 같이 수정하면 된다.
    
    ```java
    @Override
    public int compareTo(Person p) {
        return this.age - p.age;
    }
    ```
    
- Comparator<T> 인터페이스를 기반으로 TreeSet<E>의 정렬 기준 제시하기
    
    나이가 적은 사람이 앞쪽에 위치해야 한다면? 물론 메소드의 구현 내용을 수정하면 된다. 그러나 일시적인 기준 변경이라면 메소드를 수정하는 일은 적절하지 않다. 그리고 이러한 상황을 고려해서 다음 인터페이스를 제공하고 있다.
    
    ```java
    public interface Comparator<T>
    -> int compare(T o1, T o2)의 구현을 통해 정렬 기준을 정할 수 있다.
    ```
    
    이 인터페이스를 구현한 클래스의 인스턴스는 TreeSet<E>의 다음 생성자를 통해 전달 할 수 있다.
    
    ```java
    public TreeSet(Comparator<? super E> comparator)
    ```
    
    그리고 compare의 메소드의 정의 기준은 다음과 같다.
    
    int compare(T o1. T o2)
    
    - o1이 o2보다 크면 양의 정수 반환
    - o1이 o2보다 작으면 음의 정수 반환
    - o1이 o2가 같으면 0 반환
    
    ```java
    import java.util.TreeSet;
    import java.util.Iterator;
    import java.util.Comparator;
    
    class Person implements Comparable<Person> {
        String name;
        int age;
    
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
    
        @Override
        public String toString() { return name + " : " + age; }
    
        @Override
        public int compareTo(Person p) {
            return this.age - p.age;
        }
    }
    
    class PersonComparator implements Comparator<Person> {
        public int compare(Person p1, Person p2) {
            return p2.age - p1.age; 
        }
    }
    
    class ComparatorPerson {
        public static void main(String[] args) {
            TreeSet<Person> tree = new TreeSet<>(new PersonComparator());
            tree.add(new Person("YOON", 37));
            tree.add(new Person("HONG", 53));
            tree.add(new Person("PARK", 22));
    	
            for(Person p : tree)
                System.out.println(p);
        }
    }
    ```
    
    그리고 다음과 같이 위의 인스턴스 인자로 하여 TreeSet<Person> 인스턴스를 생성하였다. 따라서 이렇게 생성된 컬렉션 인스턴스는, 인자로 전달된 인스턴스의 compare 메소드 호출 결과를 바탕으로 정렬 상태를 유지하게 된다.
    
    ```java
    TreeSet<Person> tree = new TreeSet<>(new PersonComparator());
    ```
    
    다음 예제는 문자열의 기준으로 정렬하는 것이다.
    
    ```java
    import java.util.TreeSet;
    import java.util.Iterator;
    import java.util.Comparator;
    
    class StringComparator implements Comparator<String> {
        public int compare(String s1, String s2) {
            return s1.length() - s2.length();
        }
    }
    
    class ComparatorString {
        public static void main(String[] args) {
            TreeSet<String> tree = new TreeSet<>(new StringComparator());
            tree.add("Box");    
            tree.add("Rabbit");
            tree.add("Robot");
    	
            for(String s : tree)
                System.out.print(s.toString() + '\\t');
    
            System.out.println();
        }
    }
    ```
    
- 중복된 인스터스를 삭제하려면
    
    List<E>를 구현하는 컬렉션 클래스는 인스턴스의 중복 삽입을 허용한다. 그런데 저장된 인스턴스들 중에서 중복 삽입된 인스턴스들을 하나만 남기고 모두 지워야 한다고 가정해보자.
    
    ```java
    import java.util.List;
    import java.util.Arrays;
    import java.util.ArrayList;
    import java.util.HashSet;
    
    class ConvertCollection {
        public static void main(String[] args) {
            List<String> lst = Arrays.asList("Box", "Toy", "Box", "Toy");
            ArrayList<String> list = new ArrayList<>(lst);
            
            for(String s : list)
                System.out.print(s.toString() + '\\t');
            System.out.println();
    
            HashSet<String> set = new HashSet<>(list);
            list = new ArrayList<>(set);
    
            for(String s : list)
                System.out.print(s.toString() + '\\t');
            System.out.println();
        }
    }
    ```
    
    다음 예제가 핵심 문장이다.
    
    ```java
    HashSet<String> set = new HashSet<>(list);
    ```
    
    그리고 이는 다음 생성자를 통해서 컬렉션 인스턴스를 생성하는 문장이다.
    
    ```java
    public HashSet<Collection<? extends E> c)
    -> 다른 컬렉션 인스턴스로부터 HashSet<E> 인스턴스 생성
    ```
    
    위와 같이 인스턴스를 생성하면 HashSet<String> 인스턴스에 저장 대상을 복사하는 연산이 내부적으로 진행된다. 그리고 그 과정에서 Set<E> 인터페이스의 성격에 맞게 중복된 인스턴스는 걸러지게 된다.
    

## Queue<E> 인터페이스를 구현하는 컬렉션 클래스들

- 스택(Statck)과 큐(Queue)의 이해
    
    스택 ‘먼저 저장된 데이터가 나중에 나간다.’라는 개념이 이다.
    
    LIFO(Last-In-First-out)
    
    ![https://blog.kakaocdn.net/dn/bcgR9A/btqSX70PCTe/dMSMQoJcZhDpq4sRRpu3A0/img.png](LIFO.png)
    
    큐는 ‘가장먼저 들어온 데이터가 먼저 나간다.’라는 개념이다.
    
    FIFO(First-In-First-Out)
    
    ![https://blog.kakaocdn.net/dn/5NOv1/btqSTINnoq8/4f8bjzzf6W4POewlq8At31/img.png](https://blog.kakaocdn.net/dn/5NOv1/btqSTINnoq8/4f8bjzzf6W4POewlq8At31/img.png)
    
    큐와 구조가 똑같지만 양쪽에서 빼고 넣을 수 있는 ‘덱(Deque)’도 있다.
    
    ![https://blog.kakaocdn.net/dn/uOyAT/btrwb45JnaN/Ez3crtJsclaMFa4kTDz0o1/img.png](FIFO.png)
    
- Queue<E> 인터페이스와 큐(Queue)의 구현
    
    큐 자료구조를 위한 Queue<E> 인터페이스를 대표하는 세 가지 메소드는 다음과 같다.
    
    ```java
    boolean add(E e) // 넣기
    E remove()       // 꺼내기
    E element()      // 확인하기
    ```
    
    이 중에서 remove는 인스턴스의 참조 값을 반환하면서 해당 인스턴스를 저장소에서 삭제하는 메소드이다. 반면 element()는 참조 값을 반환 하지만 삭제하지 않는다. 그래서 이 메소드는 무엇이 들어있는지 확인하는 메소드라 한다.
    
    그런데 위의 세 메소드는 꺼낼 인스턴스가 없을 때 혹은 저장 공간이 부족할 때 예외를 발생시킨다. 반면에 Queue<E> 인터페이스의 다음 세 메소드는 동일한 상황에서 예외를 발생기키지 않고 해당 상황을 알리기 위한 특정 값(null, false)을 반환한다.
    
    ```java
    boolean offer(E e) // 넣기, 넣을 공간이 부족하면 false 반환
    E poll() // 꺼내기, 꺼낼 대상 없으면 null 반환
    E peek() // 확인하기, 확인할 대상이 null 반환
    ```
    
    일반적인 선택은 offer, poll, peek이다. 이유는 비어있는 상황까지도 에외가 아닌 프로그램의 정상적인 흐름으로 간주하는 경우가 대부분이기 때문이다.
    
    ```java
    import java.util.Queue;
    import java.util.LinkedList;
    
    class LinkedListQueue {
        public static void main(String[] args) {
            Queue<String> que = new LinkedList<>(); 
    
            // 데이터 저장       
            que.offer("Box");
            que.offer("Toy");
            que.offer("Robot");
    
            // 무엇이 다음에 나올지 확인
            System.out.println("next: " + que.peek());
    
            // 첫 번째, 두 번째 인스턴스 꺼내기
            System.out.println(que.poll());
            System.out.println(que.poll());
    
            // 무엇이 다음에 나올지 확인
            System.out.println("next: " + que.peek());
    
            // 마지막 인스턴스 꺼내기
            System.out.println(que.poll());
        }
    }
    ```
    
    위 예제에서 보이듯이 LinkedList<E>는 List<E> 구현하면서 동시에 Queue<E>를 구현하는 컬레션 클래스이다. 따라서 어떤한 타입의 참조변수로 참고하느냐에 따라서 ‘리스트’로도 동작하고 ‘큐’로 동작할 수 도있다.
    
- 스택(Stack)의 구현
    
    자바는 기본 자료구조 대부분을 지원한다.
    
    ```java
    public class Stack<E> extends Vector<E>
    ```
    
    그리고 Stack<E>는 멀티 쓰레드에 안전하지만 그만큼 성능이 저하된다. 그래서 덱이라는 자료구조를 쓴다.
    
    ```java
    public interface Deque<E> extends Queue<E>
    ```
    
    덱은 외형 구조가 큐와 비슷하다. 그러나 한쪽 방향으로 넣고 꺼내는 큐와 달리 덱은 양쪽 끝에서 넣고 빼는 것이 가능한 자료구조이다.
    
    Deque<E>의 대표 메소드들은 다음과 같다.
    
    - 앞으로 넣고, 꺼내고, 확인하기
        
        ```java
        void addFirst(E e)  // 넣기
        E removeFirst()  // 꺼내기
        E getFirst()  // 확인하기
        ```
        
    - 뒤로 넣고, 꺼내고, 확인하기
        
        ```java
        void addLast(E e)  // 넣기
        E removeLast()  // 꺼내기
        E getLast()  // 확인하기
        ```
        
    
    하지만 이런 메소들은 공간이 부족해서 넣지 못할 때 예외가 발생한다. 그럴때 예외를 발생시키지 않고 특정 값을 반환한다.
    
    - 앞으로 넣고, 꺼내고, 확인하기
        
        ```java
        boolean offerFirst(E e)  // 넣기, 공간이 부족하면 fasle 반환
        E pollFirst()  // 꺼내기, 꺼낼 공간이 없으면 null 반환
        E peekFirst()  // 확인하기, 확인할 대상이 없으면 null 반환
        ```
        
    - 뒤로 넣고, 꺼내고, 확인하기
        
        ```java
        boolean offerLast(E e)  // 넣기, 공간이 부족하면 fasle 반환
        E pollLast()  // 꺼내기, 꺼낼 공간이 없으면 null 반환
        E peekLast()  // 확인하기, 확인할 대상이 없으면 null 반환
        ```
        
    
    offerFirst & pollFirst 앞으로 넣고 앞에서 꺼내기
    
    offerLast & pollLast 뒤로 넣고 뒤에서 꺼내기
    
    ArrayDeque<E> 클래스의 인스턴스를 스택처럼 활용하는 예를 보이겠다.
    
    ```java
    import java.util.Deque;
    import java.util.ArrayDeque;
    
    class ArrayDequeCollection {
        public static void main(String[] args) {
            Deque<String> deq = new ArrayDeque<>(); 
    
            // 앞으로 넣고       
            deq.offerFirst("1.Box");
            deq.offerFirst("2.Toy");
            deq.offerFirst("3.Robot");
    
            // 앞에서 꺼내기
            System.out.println(deq.pollFirst());
            System.out.println(deq.pollFirst());
            System.out.println(deq.pollFirst());  
        }
    }
    ```
    
    ```java
    Deque<String> deq = new ArrayDeque<>(); 
    ```
    
    → 배열을 기반으로 하는 덱의 구성
    
    ```java
    Deque<String> deq = new LinkedDeque<>(); 
    ```
    
    → 리스트를 기반으로 하는 덱의 구성
    
    이렇게 할수 있는 이유가 이 클래스가 세 가지 인터페이스를 모두 구현하기 때문이다.
    
    ```java
    Deque<E>, List<E>, Queue<E>
    ```
    
    따라서 어느 타입의 참조변수로 참조하느냐에 따라서 LinkedList<E>는 그 성격이 결정된다. 그리고 그 스택에 대한 이야기를 조금 더하면, 스택의 두 기능인 넣고 꺼내기 연산에 대해 전통적으로 다음과 같이 이름을 붙인다.
    
    - 스택에 넣기 push
    - 스택에서 넣기 pop
    
    스택이 필효한 경우는 다음과 같이 별도의 클래스를 정의하여 사용할 것을 권장한다.
    
    ```java
    import java.util.Deque;
    import java.util.ArrayDeque;
    
    interface DIStack<E> {
        public boolean push(E item);
        public E pop();
    }
    
    class DCStack<E> implements DIStack<E> {
        private Deque<E> deq;
    
        public DCStack(Deque<E> d) {
            deq = d;
        }
    
        public boolean push(E item) {
            return deq.offerFirst(item);
        }
        
        public E pop() {
            return deq.pollFirst();
        }
    }
    
    class DefinedStack {
        public static void main(String[] args) {
        
            DIStack<String> stk = new DCStack<>(new ArrayDeque<String>()); 
    
            // PUSH 연산
            stk.push("1.Box");
            stk.push("2.Toy");
            stk.push("3.Robot");
    
            // POP 연산
            System.out.println(stk.pop());
            System.out.println(stk.pop());
            System.out.println(stk.pop());  
        }
    }
    ```
    
    위 예제에서 정의한 인터페이스와 클래스는 다음과 같다.
    
    ```java
    interface DIStack<E>
    class DCStack<E> implements DIStack<E>
    ```
    
    이 인터페이스와 클래스를 기반으로 다음과 같이 문장을 구성하면 배열 기반의 스택이 생성된다.
    
    ```java
    DIStack<String> stk = new DCStack<>(new ArrayDeque<String>());
    ```
    
    그리고 다음과 같이 문장을 구성하면 리스트 기반의 스택이 생성된다.
    
    ```java
    DIStack<String> stk = new DCStack<>(new LinkedList<String>());
    ```
    

## Map<K, V> 인테페이스를 구현하는 컬렉션 클래스들

- Key, Value 방식의 데이터 저장과 HashMap<K, V> 클래스
    
    캐비넷에 서류철을 보관할 때 해당 서류철을 쉽게 찾을 수 있도록 서류철의 특정 위치에 서류의 정보나 이름을 써넣는다. 이것이 Key, Value이다. Key는 실질적 데이터는 아니다. Value을 찾기 위한 값일뿐 Key는 중복이 되면 안되고 Value는 중복이 가능하다.
    
    “Key는 지표이므로 중복 될 수 없다. 반면 Key만 다르면 Value는 중복되어도 상관없다.”
    
    Map<K, V>를 구현하는 대표 클래스로 `HashMap<K, V>`와 `TreeMap<K, V>`가 있다. 둘의 가장 큰 차이점은, 트리 자료구조 기반으로 구현된 `TreeMap<K, V>`은 정렬 상태를 유지한다는 것이다. 물론 정렬 대상은 Value가 아니라 Key이다. 그럼 먼저 `HashMap<K, V>`의 사용의 예를 보이겠다.
    
    ```java
    import java.util.HashMap;
    
    class HashMapCollection {
        public static void main(String[] args) {
            HashMap<Integer, String> map = new HashMap<>();
            
            // Key-Value 기반 데이터 저장
            map.put(45, "Brown");
            map.put(37, "James");
            map.put(23, "Martin");
    
            // 데이터 탐색
            System.out.println("23번: " + map.get(23));
            System.out.println("37번: " + map.get(37));
            System.out.println("45번: " + map.get(45));
            System.out.println();
    
            // 데이터 삭제
            map.remove(37);
    
            // 데이터 삭제 확인
            System.out.println("37번: " + map.get(37));
        }
    }
    ```
    
    그리고 Key, Value도 인스턴스이어야 한다.
    
    ```java
    HashMap<Integer, String> map = new HashMap<>();
    ```
    
- HashMap<K, V>의 순차적 접근 방법
    
    HashMap<K, V> 클래스는 Iterable<T> 인터페이스를 구현하지 않으니 for-each 문을 통해서, 혹은 `반복자`를 얻어서 순차적 접근을 진행할 수 없다. 대신에 Map<K, V>에는 다음 메소드가 존재한다.
    
    ```java
    public Set<K> ketSet();
    ```
    
    ```java
    import java.util.HashMap;
    import java.util.Iterator;
    import java.util.Set;
    
    class HashMapIteration {
        public static void main(String[] args) {
            HashMap<Integer, String> map = new HashMap<>();
            
            // Key-Value 기반 데이터 저장
            map.put(45, "Brown");
            map.put(37, "James");
            map.put(23, "Martin");
    
            // Key만 담고 있는 컬렉션 인스턴스 생성
            Set<Integer> ks = map.keySet();
    
            // 전체 Key 출력 (for-each문 기반)
            for(Integer n : ks)
                System.out.print(n.toString() + '\\t');
            System.out.println();
    
            // 전체 Value 출력 (for-each문 기반)
            for(Integer n : ks)
                System.out.print(map.get(n).toString() + '\\t');
            System.out.println();
    
            // 전체 Value 출력 (반복자 기반)
            for(Iterator<Integer> itr = ks.iterator(); itr.hasNext(); )
                System.out.print(map.get(itr.next()) + '\\t');
            System.out.println();
        }
    }
    ```
    
    위 예제의 핵심은 다음 문장에 있다.
    
    ```java
    Set<Integer> ks = map.keySet();
    ```
    
    Set<E>는 Iterable<E>을 상속하므로 for-each문, 접근자를 통해서 순차적 접근이 가능하다.
    
    > HashMap<K, V>의 특성은 Map<K, V>의 특징을 전부 따라가기 때문에 Key의 중복은 불가능하고 Value의 값은 중복이 허용된다.
    
- TreeMap<K, V>의 순차적 접근 방법
    
    TreeMap<K, V>는 트리구조 기반으로 구현되어 있어서 정렬 상태를 유지한다.
    
    ```java
    import java.util.TreeMap;
    import java.util.Iterator;
    import java.util.Set;
    
    class TreeMapIteration {
        public static void main(String[] args) {
            TreeMap<Integer, String> map = new TreeMap<>();
            
            // Key-Value 기반 데이터 저장
            map.put(45, "Brown");
            map.put(37, "James");
            map.put(23, "Martin");
    
            // Key만 담고 있는 컬렉션 인스턴스 생성
            Set<Integer> ks = map.keySet();
    
            // 전체 Key 출력 (for-each문 기반)
            for(Integer n : ks)
                System.out.print(n.toString() + '\\t');
            System.out.println();
    
            // 전체 Value 출력 (for-each문 기반)
            for(Integer n : ks)
                System.out.print(map.get(n).toString() + '\\t');
            System.out.println();
    
            // 전체 Value 출력 (반복자 기반)
            for(Iterator<Integer> itr = ks.iterator(); itr.hasNext(); )
                System.out.print(map.get(itr.next()) + '\\t');
            System.out.println();
        }
    }
    ```
    
    ```java
    23     37    45
    Martin James Brown
    Martin James Brown
    ```
    
    위의 실행 결과에는 Key에 해당하는 나이 정보가 오름차순으로 출력되었다. 이렇듯 대상 컬렉션 인스턴스에 따라서 반환되는 반복자의 성격은 달라진다. TreeMap<K, V> 인스턴스에 반환된 반복자는 오름차순으로 Key에 접근한다.
    
    이번에는 내림차순으로 나이 정보가 출력되도록 예제를 수정해보자.
    
    ```java
    import java.util.TreeMap;
    import java.util.Iterator;
    import java.util.Set;
    import java.util.Comparator;
    
    class AgeComparator implements Comparator<Integer> {
        public int compare(Integer n1, Integer n2) {
            return n2.intValue() - n1.intValue(); 
        }
    }
    
    class ComparatorTreeMap {
        public static void main(String[] args) {
            TreeMap<Integer, String> map = new TreeMap<>(new AgeComparator());
            
            // Key-Value 기반 데이터 저장
            map.put(45, "Brown");
            map.put(37, "James");
            map.put(23, "Martin");
    
            // Key만 담고 있는 컬렉션 인스턴스 생성
            Set<Integer> ks = map.keySet();
    
            // 전체 Key 출력 (for-each문 기반)
            for(Integer n : ks)
                System.out.print(n.toString() + '\\t');
            System.out.println();
    
            // 전체 Value 출력 (for-each문 기반)
            for(Integer n : ks)
                System.out.print(map.get(n).toString() + '\\t');
            System.out.println();
    
            // 전체 Value 출력 (반복자 기반)
            for(Iterator<Integer> itr = ks.iterator(); itr.hasNext(); )
                System.out.print(map.get(itr.next()) + '\\t');
            System.out.println();
        }
    }
    ```
    
    Compartor<T>를 구현하는 AgeComparator 클래스를 정의하고, 다음과 같이 TreeMap<K, V> 인스턴스를 생성한 것이 수정 내용 전부이다.
    
    ```java
    TreeMap<Integer, String> map = new TreeMap<>(new AgeCompartor()); 
    ```
    
    그리고 정렬 대상이 Comparator<Integer>으로 되어있는데 Integer로 T가 선언된 이유는 바로 정렬 대상인 Key가 Integer이기 때문이다.