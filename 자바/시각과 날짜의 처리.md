- 시간이 얼마나 걸렸지? : Instant 클래스
    
    - 시각: 시간의 한 시점
    - 시간: 어떤 시각에서 어떤 시각까지의 사이
    
    첫 번째로 소개할 클래스는 java.time.Instant이다. 이는 ‘흐르는 시간 속’에서의 ‘특정 시점’을 표현하기 위한 클래스이다. 이 클래스의 인스턴스 생성 방법은 다음과 같다.
    
    ```java
    Instant  now = Instant.now();
    	-> now 메소드 호출을 통한 Instant 인스턴스의 생성
    ```
    
    위의 문자을 실행하면 now가 참조하는 인스턴스에는 now 메소드가 호출된 시점의 시각 정보가 담긴다. 이와 관려하여 다음 예제를 보자.
    
    ```java
    import java.time.Instant;
    import java.time.Duration;
    
    class InstantDemo {
        public static void main(String[] args) {
            Instant start = Instant.now();
            System.out.println("시작: " + start.getEpochSecond());
            
            System.out.println("Time flies like an arrow.");
    
            Instant end = Instant.now();        
            System.out.println("끝: " + end.getEpochSecond());    
    
            Duration between = Duration.between(start, end);
            System.out.println("밀리 초 단위 차: " + between.toMillis());
         }
    }
    ```
    
    ```java
    시작: 1482296670
    Time flies like an arrow.
    끝: 1482296670
    밀리 초 단위 차: 6
    ```
    
    위 예제에서는 다음 문장을 실행하여 현재 시각 정보를 담은 Instant 인스턴스를 생성하였다.
    
    ```java
    Instant start = Instant.now();
    ```
    
    그리고 다음 메소드 호출을 통해 저장된 시각 정보를 반환하였다.
    
    ```java
    start.getEpochSeconde()
    ```
    
    이때 반환되는 값은 ‘1970-01-01 00:00:00’을 기준으로(이 기준을 ‘표준 자바 epoch’라 한다.) 지나온 시간을 초 단위로 계산한 결과이다. 즉 실행결과에서 1482296670이 출력되었는데, 이는 표준 자바 epoch기준으로 1482296670초가 지난 시점에 now 메소드가 호출 되었음을 의미한다. 따라서 다음과 같은 패턴의 코드를 적용하면 초 단위 정밀도를 가진 스톱위치 효과를 얻을 수 있다.
    
    ```java
    Instant start = Instatn.now();
    // 시간 측정 대상 문장들은 이 사이에 온다.
    Instant end = Instant.now();
    System.out.println(end.getEpochSecond() - start.getEpochSecond());
    ```
    
    그러나 보다 높은 정밀도를 측정해야 한다면, 예를 들어서 밀리 초 단위의 정밀도를 요구한다면 다음과 같은 패턴의 코드를 적용해야 한다. Instant 클래스는 나노 초까지의 정밀도를 지원하므로 다음과 같이 시간차를 구하는 방법만 달리하면, 밀리 초 단위(1 / 1000초 단위) 정밀도를 가진 스톱위치 효과를 낼 수 있다.
    
    ```java
    Instant start = Instatn.now();
    // 시간 측정 대상 문장들은 이 사이에 온다.
    Instant end = Instant.now();
    Duration between = Duration.between(start, end);
    System.out.println("밀리 오 단위 차: " + between.toMillis());
    ```
    
    java.time.Duration은 시간을(시각의 차를) 표현하는 클래스이다. 따라서 Duration 인스턴스를 다음과 같이 생성하면 이 인스턴스 내에는 start와 end의 시각 차 정보가 담긴다.
    
    ```java
    Dueation between = Duration.between(start, end);
    ```
    
    그리고 여기에 담긴 시간 정보는 다음 문장을 통해서 1/1000초 단위의 정밀도로 확인할 수 있다.
    
    ```java
    System.out.println("밀리 초 단위 차:" + between.toMillis());
    ```
    
    ```java
    import java.util.List;
    import java.util.Arrays;
    import java.time.Instant;
    import java.time.Duration;
    
    class HowLongSequential {
        public static long fibonacci(long n) {
            if(n == 1 || n == 2)
                return 1;
            
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    
        public static void main(String[] args) {
            List<Integer> nums = Arrays.asList(41, 42, 43, 44, 45, 46);
            
            Instant start = Instant.now();
            
            nums.stream()
               .map(n -> fibonacci(n))
               .forEach(r -> System.out.println(r));
            
            Instant end = Instant.now();
            System.out.println("Sequential Processing Time: " +
                Duration.between(start, end).toMillis());
        }
    }
    ```
    
    ```java
    165580141
    267914296
    433494437
    701408733
    1134903170
    1836311903
    Sequential Processing Time: 8890
    ```
    
    위 예제에서는 피보나치 수열의 마지막 값을 반환하는 메소드를 다음과 같이 정의하고,
    
    ```java
    public static long fibonacci(long n) {
            if(n == 1 || n == 2)
                return 1;
            
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    ```
    
    다음 컬렉션 인스턴스를 대상으로 스트림을 생성하여, 위 메소드를 호출하는 파이프라인을 구성하였다.
    
    ```java
    List<Integer> nums = Arrays.adList(40, 41, 42, 43, 44, 45);
    ```
    
    결과적으로 위의 컬렉션 인스턴스에 저장된 정수들을 인자로 하나씩 전달하여 fibonacci 메소드 호출을 완료하기까지 걸린 시간은 다음과 같다.
    
    ```java
    Sequential Processing Time: 50999
    ```
    
    그럼 이어서 병렬 스트림을 구성했을 때 어느 정도의 시간적 이득이 발생하는지 다음 예제를 통해서 확인해 보자.
    
    ```java
    import java.util.List;
    import java.util.Arrays;
    import java.time.Instant;
    import java.time.Duration;
    
    class HowLongParallel {
        public static long fibonacci(long n) {
            if(n == 1 || n == 2)
                return 1;
            
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    
        public static void main(String[] args) {
            List<Integer> nums = Arrays.asList(41, 42, 43, 44, 45, 46);
            
            Instant start = Instant.now();
            
            nums.parallelStream()
               .map(n -> fibonacci(n))
               .forEach(r -> System.out.println(r));
            
            Instant end = Instant.now();
            System.out.println("Parallel Processing Time: " + 
                Duration.between(start, end).toMillis());
        }
    }
    ```
    
    ```java
    165580141
    267914296
    433494437
    701408733
    1134903170
    1836311903
    Parallel Processing Time: 4098
    ```
    
    확실히 빨라졌다. 약 두배정도 빨라진 것을 숫자를 통해 알 수 있다. 그러나 이것이 병렬 스트림에 언제나 유리하다는 의미는 아니다. fibonacci 메소드에 전달할 인자들은 다음과 같이 수정했을 때에는 오히려 순차 스트림의 실행 속도가 더 빨랐다.
    
    ```java
    List<Integer> nums = Arrays.asList(5, 6, 7, 8, 9);
    ```
    
- 오늘이 며칠이죠? LocalDate 클래스
    
    LocalDate는 시각 정보가 생략된 ‘날짜 정보’를 표현하기 위한 클래스이다. 예제를 통한 이해가 빠르므로 바로 예제를 소개하겠다.
    
    ```java
    import java.time.LocalDate;
    
    class LocalDateDemo1 {
        public static void main(String[] args) {
            // 오늘
            LocalDate today = LocalDate.now();
            System.out.println("Today: " + today);
        
            // 올 해의 크리스마스
            LocalDate xmas = LocalDate.of(today.getYear(), 12, 25);
            System.out.println("Xmas: " + xmas);
    
            // 올 해의 크리스마스 이브
            LocalDate eve = xmas.minusDays(1);
            System.out.println("Xmas Eve: " + eve);        
        }
    }
    ```
    
    ```java
    Today: 2024-03-19
    Xmas: 2024-12-25
    Xmas Eve: 2024-12-24
    ```
    
    위 예제의 첫 문장은 다음과 같다. 이 문장을 통해서 오늘의 날짜 정보를 담은 LocalDate 인스턴스를 생성할 수 있다.
    
    ```java
    LocalDate today = LocalDate.now();
    ```
    
    그리고 LocalDate의 toString 메소드는 날짜 정보를 2017-09-09와 같은 형태의 문자열로 반환하니 다음과 같이 그 내용을 출력할 수 있다.
    
    ```java
    System.out.println("Today: " + today);
    ```
    
    이어서 다음 문장을 보자. 이 문장에서는 인자로 지정한 날짜 정보를 담은 LocalDate 인스턴스를 생성하기 위해 of 메소드를 호출하였다.
    
    ```java
    LocalDate xmas = LocalDate.of(today.getYear(), 12 , 25);
    -> public static LocalDate of(int year, int month, int dayOfMonth)
    ```
    
    LocalDate의 getYear는 연도 정보를 반환한다. 따라서 위의 문장으로 인해 올해의 크리스마스 날짜 정보가 담긴 LocalDate 인스턴스가 생성된다. 이어서 다음 문자을 보자. 이 문장은 LocalDate 인스턴스가 변경 불가능한(immutable) 인스턴스임을 보인다.
    
    ```java
    LocalDate eve = xmas.minusDays(1); // 일 정보를 1 감소
    ```
    
    위의 문장에서 보이듯이 메소드 호출을 통해 저장된 날짜 값을 변경할 수 있다. 단 기존에 저장된 날짜 정보를 수정하는 것이 아니라, 변경된 날짜 정보를 갖는 LocalDate 인스턴스를 새로 생성해서 이를 반환하는 형태로 진행이 된다.
    
    참고로 LocalDate 인스턴스의 날짜 정보를 변경할 수 있도록 다음 메소드들이 정의되어 있다. 그리고 이들 각각에 상응하는 plusXXX 메소드들도 정의되어 있다.
    
    ```java
    public LocalDate minusYears(long yearsToSubtract) // LocalDate의 메소드
    public LocalDate minusMonths(long monthsToSubtract) // LocalDate의 메소드
    public LocalDate minusDays(long daysToSubtract) // LocalDate의 메소드
    ```
    
    앞서 Instant 클래스를 소개하면서 시각의 차를 표현하기 위한 Duraction 클래스를 소개하였다. 이와 유사하게 날짜의 차를 표현하기 위한 Period 클래스도 존재한다. 그럼 다음 예제를 통해 이 클래스의 사용의 예를 보이겠다.
    
    ```java
    import java.time.LocalDate;
    import java.time.Period;
    
    class LocalDateDemo2 {
        public static void main(String[] args) {
            // 오늘
            LocalDate today = LocalDate.now();
            System.out.println("Today: " + today);
        
            // 올 해의 크리스마스
            LocalDate xmas = LocalDate.of(today.getYear(), 12, 25);
            System.out.println("Xmas: " + xmas);
    
            // 크리스마스까지 앞으로 며칠?
            Period left = Period.between(today, xmas);
            System.out.println("Xmas까지 앞으로 " + 
                     left.getMonths() + "월 " + left.getDays() + "일");
        }
    }
    ```
    
    ```java
    Today: 2024-03-19
    Xmas: 2024-12-25
    Xmas까지 앞으로 9월 6일
    ```
    
    예제에서 보이듯이 between 메소드 호출을 통해서, 인자로 전달된 두 날짜의 차를 담은 Period 인스턴스를 생성할 수 있다.
    
    ```java
    Period left = Period.between(today, xmas);
    ```
    
    그리고 다음 메소드 호출을 통해 Period 인스턴스에 저장된 년, 월, 일 정보를 각각 얻을 수 있다.
    
    ```java
    public int getYears() // Period 메소드
    public int getMonths() // Period 메소드
    public int getDays() // Period 메소드
    ```
    
- 3시간 10분 뒤에 어때? : LocalTime 클래스
    
    LocalDate가 날짜 정보를 나타내는 클래스라면 이번에 소개하는 LocalTime은 시각 정보를 나타내는 클래스이다. 그럼 이와 관련하여 다음 예제를 보자.
    
    ```java
    import java.time.LocalTime;
    
    class LocalTimeDemo1 {
        public static void main(String[] args) {
            // 현재 시각
            LocalTime now = LocalTime.now();
            System.out.println("지금 시각: " + now);
    
            // 2시간 10분 뒤 화상 미팅 예정
            LocalTime mt = now.plusHours(2);
            mt = mt.plusMinutes(10);
    
            // 화상 미팅 시각
            System.out.println("화상 미팅 시각: " + mt);
        }
    }
    
    ```
    
    ```java
    지금 시각: 22:30:29.343269
    화상 미팅 시각: 00:40:29.343269
    ```
    
    위 예제의 첫 문장은 다음과 같다. 이 문장을 통해서 현재의 시각 정보를 담은 LocalTime 인스턴스를 생성하였다.
    
    ```java
    LocalTime now = LocalTime.now();
    ```
    
    그리고 LocalTime의 toString 메소드는 시각 정보를 시:분:초 형태의 문자열로 반환하니, 다음 문장을 통해 시각 정보를 출력할 수 있다. (실행 결과에서는 1/1000초 단위까지 출력이 이뤄졌다.)
    
    ```java
    System.out.println("Today: " + today);
    ```
    
    이어서 다음 두 문장을 보자. 이 두 문장은 LocalTime 인스턴도 변경 불가능한 인스턴스임을 보인다.
    
    ```java
    LocalTime mt = now.plusHours(2); // 시 정보를 2 증가
    mt = mt.plusMinuntes(10); // 분 정보를 10 증가
    ```
    
    위의 문장에서 보이듯이 메소드 호출을 통해 저장된 시각 정보를 바꿀 수 있다. 단 기존에 저장된 시각 정보를 수정하는 것이 아니라 변경된 시각 정보를 갖는 LocalTime 인스턴스를 새로 생성하여 이를 반환하는 형태로 진행이 된다. 참고로 LocalTime 인스턴스의 시각 정보를 바꿀 수 있도록 다음 메소들이 정의되어 있다. 그리고 이들 각각에 상응하는 munusXXX 메소드들도 정의되어 있다.
    
    ```java
    public LocalTime plusHours(long hoursToAdd) // LocalTime의 매소드
    public LocalTime plusMinutes(long minutesToAdd) // LocalTime의 메소드
    public LocalTime plusSeconds(long secondtoAdd) // LocalTime의 메소드
    ```
    
    앞서 Instant 클래스를 소개하면서 시간 정보는(시각 차 벙보는) Duration 인스턴스로 표현함을 설명하였다. 마찬가지로 두 LocalTIme 인스턴스 사이의 시간 정보도 Duration 인스턴스로 표현한다. 이와 관련하여 다음 예제를 보자.
    
    ```java
    import java.time.LocalTime;
    import java.time.Duration;
    
    class LocalTimeDemo2 {
        public static void main(String[] args) {
            // PC방의 PC 이용 시작 시각
            LocalTime start = LocalTime.of(14, 24, 35);
            System.out.println("PC 이용 시작 시각: " + start);
    
            // PC방의 PC 이용 종료 시각
            LocalTime end = LocalTime.of(17, 31, 19);
            System.out.println("PC 이용 종료 시각: " + end);
    
            // PC 이용 시간 계산
            Duration between = Duration.between(start, end);
            System.out.println("총 PC 이용 시간: " + between);        
        }
    }
    
    ```
    
    ```java
    PC 이용 시작 시각: 14:24:35
    PC 이용 종료 시각: 17:31:19
    총 PC 이용 시간: PT3H6M44S
    ```
    
    위 예제에서는 LocalTime 클래스의 of 메소드 호출을 통해서 특정 시각 정보를 담은 LocalTime 인스턴스를 생성하였다. 그리고 다음과 같이 두 시각 차를 담은 Duration 인스턴스를 생성하였다.
    
    ```java
    Duration between = Duration.between(start, end);
    ```
    
    그리고 Duration의 toString 메소드가 반환하는 시간 정보를 다음과 같으면, 이는 3시간 6분 44초를 의미한다.
    
    ```java
    PT3H6M44S
    ```
    
    위의 출력 내용은 ISO-8601의 시각을 나타내는 포맷을 기반으로 작성되었다. 물론 원하는 형태가 다르면 바꾸어서 출력할 수 있다. 그리고 그 방법을 본 Chapter 마지막 부분에서 설명한다.
    
- 지금으로부터 22시간 35분 뒤의 시각과 날짜는? : LocalDateTime 클래스
    
    LocalDate는 날짜 정보를 LocalTime은 시각 정보를 나타내지만, 이어서 소개하는 LocalDataTime 클래스는 시각 정보와 날짜 정보를 동시에 나타낸다. 이와 관련하여 다음 예제를 보자.
    
    ```java
    import java.time.LocalDateTime;
    
    class LocalDateTimeDemo1 {
        public static void main(String[] args) {
            // 현재 날짜와 시각
            LocalDateTime dt = LocalDateTime.now();
            System.out.println(dt);
    
            // 영국 바이어와 22시간 35분 뒤 화상 미팅 예정
            LocalDateTime mt = dt.plusHours(22);
            mt = mt.plusMinutes(35);
    
            // 영국 바이어와 화상 미팅 날짜와 시각
            System.out.println(mt);
        }
    }
    
    ```
    
    ```java
    지금 시각: 19:31:01.375224
    화상 미팅 시각: 21:41:01.375224
    ```
    
    위 예제에서는 다음 문장을 통해 now 메소드가 호출된 시점의 날짜와 시각 정보를 함께 담은 인스턴스를 생성하였다.
    
    ```java
    LocalDateTime dt = LocalDateTime.now();
    ```
    
    그리고 이어서 다음 문장을 통해서 toString 메소드가 반환하는 날짜와 시각 정보를 출력하였다.
    
    ```java
    System.out.println(dt);
    ```
    
    이때의 출력 결과는 다음과 같다. 이는 날짜가 2016년 12월 22일이고 시각이 22시 19분 12.258초 임을 나타낸다.
    
    ```java
    2016-12-22T22:19:12.258
    ```
    
    이어서 다음 두 문장을 보자. 이는 LocalDateTime 인스턴스도 변경 불가능한(immutable) 인스턴스임을 보여준다.
    
    ```java
    LocalDateTime mt = dt.plusHours(22);
    mt = mt.plusMinutes(35);
    ```
    
    그리고 LocalDateTime에 저장된 년, 월, 일 그리고 시, 분, 초 정보는 다음 메소드 호출을 통해서 얼마든지 수정할 수 있다. 물론 이들 각각에 상응하는 minusXXX 메소드도 정의되어 있다.
    
    ```java
    public LocalDateTime plusYears(long years)
    public LocalDateTime plusMonths(long months)
    public LocalDateTime plusDays(long days)
    
    public LocalDateTime plusHours(long hours)
    public LocalDateTime plusMinutes(long minutes)
    public LocalDateTime plusSeconds(long seconds)
    ```
    
    예제를 하나 더 보이겠다. 이 예제에서는 시각 비교에 사용하는 LocalDateTime의 isBefore 메소드를 소개한다. 그리고 두 LocalDateTime 인스턴스 간의 시각과 날짜의 차를 구하는 방법도 소개한다.
    
    ```java
    import java.time.LocalDateTime;
    import java.time.Period;
    import java.time.Duration;
    
    class LocalDateTimeDemo2 {
        public static void main(String[] args) {
            // 현재 시각
            LocalDateTime today = 
                    LocalDateTime.of(2020, 4, 25, 11, 20);
    
            // 항공편1의 출발 시간
            LocalDateTime flight1 = 
                    LocalDateTime.of(2020, 5, 14, 11, 15);
            
            // 항공편2의 출발 시간
            LocalDateTime flight2 = 
                    LocalDateTime.of(2020, 5, 13, 15, 30);
    
            // 빠른 항공편을 선택하는 과정
            LocalDateTime myFlight;
        
            if(flight1.isBefore(flight2))
                myFlight = flight1;
            else
                myFlight = flight2;
    
            // 빠른 항공편의 비행 탑승까지 남은 날짜 계산
            Period day = Period.between(today.toLocalDate(), myFlight.toLocalDate());
    
            // 빠른 항공편의 비행 탑승까지 남은 시간 계산
            Duration time = Duration.between(today.toLocalTime(), myFlight.toLocalTime());
    
            // 비행 탑승까지 남은 날짜와 시간 출력
            System.out.println(day);
            System.out.println(time);
        }
    }
    ```
    
    ```java
    P18D
    PT4H10M
    ```
    
    위 예제에서 호출한 LocalDateTime의 of 메소드는 다음과 같다. 그러나 초 정보까지 인자로 전달받는 of 메소드를 비롯하여 of 메소드는 다양하게 오버로딩 되어 있다.
    
    ```java
    public static LocalDateTime of (
    	int year, int month, int dayofMonth, int hour, int minute)
    ```
    
    그리고 예제에서 LocalDateTime 인스턴스 생성 이후에, 이를 대상으로 다음과 같이 isBefore 메소드를 호출하였다.
    
    ```java
    flight1.isBefore(flight2) // flight1이 flight1보다 이전인가?
    ```
    
    위 메소드의 호출 결과 flight1의 날짜와 시각이 flight2의 날짜와 시각보다 앞서면 true가 반환되고 그렇지 않으면 false가 반환된다. 그리고 이와 성격이 유사한 isAfter 메소듣도 정의되어 있어서 위의 메소드 호출을 다음과 같이 변경할 수 있다.
    
    ```java
    flight2.isAfter(flight1) // flight2가 flight1보다 이후인가?
    ```
    
    이런한 ifBefore, ifAfter 메소드는 앞서 소개한 Instant, LocalDate, LocalTime 클래스에도 정의되어 있어서 날짜 또는 시각의 전후 관계를 쉽게 따질 수 있다.
    
    이어서 위 예제의 다음 두 문장을 보자. 첫 번째 문장은 날짜의 차를, 두 번째 문장은 시각의 차를 구하는 문장이다.
    
    ```java
    Period day = Period.between(today.toLocalDate(), myFlight.toLocalDate());
    Duration time = Duration.between(today.toLocalTime(), myFlight.toLocalTime());
    ```
    
    LocalDateTime은 날짜와 시각 정보를 동시에 표현한다. 반면 Period는 날짜의 차를, Duration은 시각의 차를 표현한다. 따라서 두 LocalDateTime 인스턴스의 날짜와 시각의 차를 구하려면 위에서 보이듯이, 날짜의 차와 시각의 차를 각각 구해야 한다. 그리고 이를 위해 LocalDateTime 클래스는 다음 두 메소드를 정의하고 있다.
    
    ```java
    public LocalDate toLocalDate()
    -> 날짜에 대한 정보를 LocalDate 인스턴스에 담아서 반환
    ```
    
    ```java
    public LocalTime toLocalTime()
    -> 시각에 대한 정보를 LocalTime 인스턴스에 담아서 반환
    ```
    
    그리고 만약에 두 LocalDateTime 인스턴스의 ‘날짜와 시각의 차’를 ‘시각의 관점’에서만 계산하기 원한다면(하루를 24시간으로 환산하여 계산하기 원한다면) 다음 예제와 같이 코드를 작성하면 된다.
    
    ```java
    import java.time.Duration;
    import java.time.LocalDateTime;
    import java.time.Month;
    
    class DurationDemo {
        public static void main(String[] args) {
            LocalDateTime dt1 = LocalDateTime.of(2020, Month.JANUARY, 12, 15, 30);
            LocalDateTime dt2 = LocalDateTime.of(2020, Month.FEBRUARY, 12, 15, 30);
      
            LocalDateTime dt3 = LocalDateTime.of(2020, Month.JANUARY, 12, 15, 30);
            LocalDateTime dt4 = LocalDateTime.of(2020, Month.FEBRUARY, 13, 14, 29);
    
            Duration drDate1 = Duration.between(dt1, dt2);
            System.out.println(drDate1);
    
            Duration drDate2 = Duration.between(dt3, dt4);
            System.out.println(drDate2);
        }
    }
    ```
    
    ```java
    PT744H
    PT766H59M
    ```
    
    위 예제에서 호출한 LocalDateTime의 of 메소드는 다음과 같다.
    
    ```java
    public static LocalDateTime of (
    		int year, Month month, int datOfMonth, int hour, int minute)
    ```
    
    위의 메소드를 호출하면 1월을 의미하는 숫자 1을 대신해서 열거형 값 Month.JANUARY를 2월을 의미하는 숫자 2를 대신하여 열거형 값 Month.FEBRUARY를 전달하여 가독성을 개선할 수 있다.(나머지 달에 대한 열거형 값의 이름은 자바 문서를 참고하자. 열거형 Month를 찾으면 된다.)
    
    그리고 다음과 같이 Duration.between 메소드의 인자로 LocalDateTime 인스턴스 둘을 전달하면 날짜가 시각 정보로 환산되어 시각의 차가 계산된다.
    
    ```java
    Duration drDate1 = Duration.between(dt1, dt2);
    ```
    
    예제의 첫 번째 출력 내용은 다음과 같다. 이는 744시간의 차가 있음을 의미한다. 그리고 이는 날짜의 차가 시각의 차로 전부 확산된 결과이다.
    
    ```java
    PT744H
    ```
    
    그리고 두 번째 출력 내용은 다음과 같다. 이는 766시간 59분의 차를 의미한다.
    
    ```java
    PT766H59M
    ```
    

## 31-2 시간대의 적용한 코드 작성 그리고 출력 포맷의 지정

- 세계의 시간대
    
    시차는 1972년 1월 1부로 시행된 세계적인 약속이다. 그리고 약속의 기준이 되는 시간을 기리켜 ‘협정 세계시(Universal Time Coordinated)’ 또는 간단히 UTC라고 한다. 한국의 시간대는 UTC + 9이다. 협정 세계시보다 9시간이 빠름을 의미한다.
    
- 시간대를 표현하는 Zoneld 클래스
    
    시간대를 고려하여 코드를 작성하려면 특정 시간대 정보를 담고 있는 ZoneId 인스턴스를 생성해야 한다. 예를 들어서 파리의 시간대를 반영한 코드를 작성하려면 다음과 같이 ZoneId 인스턴스를 생성해야 한다.
    
    ```java
    import java.time.ZoneId;
    
    class ZoneIdDemo1 {
        public static void main(String[] args) {
            ZoneId paris = ZoneId.of("Europe/Paris");
            System.out.println(paris);
        }
    }
    ```
    
    ```java
    Europe/Paris
    ```
    
    위에서 주먹할 부분은 다음과 같다.
    
    ```java
    ZoneId paris = ZoneId.of("Europe/Paris");
    ```
    
    이렇듯 나라나 도시의 시간대 정보를 담은 ZoneId 인스턴스를 생성하려면 그에 맞는 문자열 정보를 전달해야 한다. 즉 파리의 시간대를 적용하려면 “Europe/Paris"를 전달해야 한다. 그렇다면 이러한 문자열 정보는 어디서 확인할 수 있을까? 개인적으로는 다음과 같이 간단한 코드를 만들어서 확인하는 방법을 추천하고 싶다.
    
    ```java
    import java.time.ZoneId;
    
    class ZoneIdDemo2 {
        public static void main(String[] args) {
            ZoneId.getAvailableZoneIds()
                .stream()
           //     .filter(s -> s.startsWith("Asia"))
                .sorted()
                .forEach(s -> System.out.println(s));
        }
    }
    ```
    
    - 출력결과
        
        ```java
        /Library/Java/JavaVirtualMachines/jdk-11.0.17.jdk/Contents/Home/bin/java -javaagent:/Users/hansanghui/Applications/IntelliJ IDEA Ultimate.app/Contents/lib/idea_rt.jar=51567:/Users/hansanghui/Applications/IntelliJ IDEA Ultimate.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Users/hansanghui/projects/vacationJavaStudy/out/production/vacationJavaStudy:/Users/hansanghui/.m2/repository/org/jetbrains/kotlin/kotlin-stdlib-jdk8/1.9.0/kotlin-stdlib-jdk8-1.9.0.jar:/Users/hansanghui/.m2/repository/org/jetbrains/kotlin/kotlin-stdlib/1.9.0/kotlin-stdlib-1.9.0.jar:/Users/hansanghui/.m2/repository/org/jetbrains/kotlin/kotlin-stdlib-common/1.9.0/kotlin-stdlib-common-1.9.0.jar:/Users/hansanghui/.m2/repository/org/jetbrains/annotations/13.0/annotations-13.0.jar:/Users/hansanghui/.m2/repository/org/jetbrains/kotlin/kotlin-stdlib-jdk7/1.9.0/kotlin-stdlib-jdk7-1.9.0.jar ZoneIdDemo2
        Africa/Abidjan
        Africa/Accra
        Africa/Addis_Ababa
        Africa/Algiers
        Africa/Asmara
        Africa/Asmera
        Africa/Bamako
        Africa/Bangui
        Africa/Banjul
        Africa/Bissau
        Africa/Blantyre
        Africa/Brazzaville
        Africa/Bujumbura
        Africa/Cairo
        Africa/Casablanca
        Africa/Ceuta
        Africa/Conakry
        Africa/Dakar
        Africa/Dar_es_Salaam
        Africa/Djibouti
        Africa/Douala
        Africa/El_Aaiun
        Africa/Freetown
        Africa/Gaborone
        Africa/Harare
        Africa/Johannesburg
        Africa/Juba
        Africa/Kampala
        Africa/Khartoum
        Africa/Kigali
        Africa/Kinshasa
        Africa/Lagos
        Africa/Libreville
        Africa/Lome
        Africa/Luanda
        Africa/Lubumbashi
        Africa/Lusaka
        Africa/Malabo
        Africa/Maputo
        Africa/Maseru
        Africa/Mbabane
        Africa/Mogadishu
        Africa/Monrovia
        Africa/Nairobi
        Africa/Ndjamena
        Africa/Niamey
        Africa/Nouakchott
        Africa/Ouagadougou
        Africa/Porto-Novo
        Africa/Sao_Tome
        Africa/Timbuktu
        Africa/Tripoli
        Africa/Tunis
        Africa/Windhoek
        America/Adak
        America/Anchorage
        America/Anguilla
        America/Antigua
        America/Araguaina
        America/Argentina/Buenos_Aires
        America/Argentina/Catamarca
        America/Argentina/ComodRivadavia
        America/Argentina/Cordoba
        America/Argentina/Jujuy
        America/Argentina/La_Rioja
        America/Argentina/Mendoza
        America/Argentina/Rio_Gallegos
        America/Argentina/Salta
        America/Argentina/San_Juan
        America/Argentina/San_Luis
        America/Argentina/Tucuman
        America/Argentina/Ushuaia
        America/Aruba
        America/Asuncion
        America/Atikokan
        America/Atka
        America/Bahia
        America/Bahia_Banderas
        America/Barbados
        America/Belem
        America/Belize
        America/Blanc-Sablon
        America/Boa_Vista
        America/Bogota
        America/Boise
        America/Buenos_Aires
        America/Cambridge_Bay
        America/Campo_Grande
        America/Cancun
        America/Caracas
        America/Catamarca
        America/Cayenne
        America/Cayman
        America/Chicago
        America/Chihuahua
        America/Coral_Harbour
        America/Cordoba
        America/Costa_Rica
        America/Creston
        America/Cuiaba
        America/Curacao
        America/Danmarkshavn
        America/Dawson
        America/Dawson_Creek
        America/Denver
        America/Detroit
        America/Dominica
        America/Edmonton
        America/Eirunepe
        America/El_Salvador
        America/Ensenada
        America/Fort_Nelson
        America/Fort_Wayne
        America/Fortaleza
        America/Glace_Bay
        America/Godthab
        America/Goose_Bay
        America/Grand_Turk
        America/Grenada
        America/Guadeloupe
        America/Guatemala
        America/Guayaquil
        America/Guyana
        America/Halifax
        America/Havana
        America/Hermosillo
        America/Indiana/Indianapolis
        America/Indiana/Knox
        America/Indiana/Marengo
        America/Indiana/Petersburg
        America/Indiana/Tell_City
        America/Indiana/Vevay
        America/Indiana/Vincennes
        America/Indiana/Winamac
        America/Indianapolis
        America/Inuvik
        America/Iqaluit
        America/Jamaica
        America/Jujuy
        America/Juneau
        America/Kentucky/Louisville
        America/Kentucky/Monticello
        America/Knox_IN
        America/Kralendijk
        America/La_Paz
        America/Lima
        America/Los_Angeles
        America/Louisville
        America/Lower_Princes
        America/Maceio
        America/Managua
        America/Manaus
        America/Marigot
        America/Martinique
        America/Matamoros
        America/Mazatlan
        America/Mendoza
        America/Menominee
        America/Merida
        America/Metlakatla
        America/Mexico_City
        America/Miquelon
        America/Moncton
        America/Monterrey
        America/Montevideo
        America/Montreal
        America/Montserrat
        America/Nassau
        America/New_York
        America/Nipigon
        America/Nome
        America/Noronha
        America/North_Dakota/Beulah
        America/North_Dakota/Center
        America/North_Dakota/New_Salem
        America/Nuuk
        America/Ojinaga
        America/Panama
        America/Pangnirtung
        America/Paramaribo
        America/Phoenix
        America/Port-au-Prince
        America/Port_of_Spain
        America/Porto_Acre
        America/Porto_Velho
        America/Puerto_Rico
        America/Punta_Arenas
        America/Rainy_River
        America/Rankin_Inlet
        America/Recife
        America/Regina
        America/Resolute
        America/Rio_Branco
        America/Rosario
        America/Santa_Isabel
        America/Santarem
        America/Santiago
        America/Santo_Domingo
        America/Sao_Paulo
        America/Scoresbysund
        America/Shiprock
        America/Sitka
        America/St_Barthelemy
        America/St_Johns
        America/St_Kitts
        America/St_Lucia
        America/St_Thomas
        America/St_Vincent
        America/Swift_Current
        America/Tegucigalpa
        America/Thule
        America/Thunder_Bay
        America/Tijuana
        America/Toronto
        America/Tortola
        America/Vancouver
        America/Virgin
        America/Whitehorse
        America/Winnipeg
        America/Yakutat
        America/Yellowknife
        Antarctica/Casey
        Antarctica/Davis
        Antarctica/DumontDUrville
        Antarctica/Macquarie
        Antarctica/Mawson
        Antarctica/McMurdo
        Antarctica/Palmer
        Antarctica/Rothera
        Antarctica/South_Pole
        Antarctica/Syowa
        Antarctica/Troll
        Antarctica/Vostok
        Arctic/Longyearbyen
        Asia/Aden
        Asia/Almaty
        Asia/Amman
        Asia/Anadyr
        Asia/Aqtau
        Asia/Aqtobe
        Asia/Ashgabat
        Asia/Ashkhabad
        Asia/Atyrau
        Asia/Baghdad
        Asia/Bahrain
        Asia/Baku
        Asia/Bangkok
        Asia/Barnaul
        Asia/Beirut
        Asia/Bishkek
        Asia/Brunei
        Asia/Calcutta
        Asia/Chita
        Asia/Choibalsan
        Asia/Chongqing
        Asia/Chungking
        Asia/Colombo
        Asia/Dacca
        Asia/Damascus
        Asia/Dhaka
        Asia/Dili
        Asia/Dubai
        Asia/Dushanbe
        Asia/Famagusta
        Asia/Gaza
        Asia/Harbin
        Asia/Hebron
        Asia/Ho_Chi_Minh
        Asia/Hong_Kong
        Asia/Hovd
        Asia/Irkutsk
        Asia/Istanbul
        Asia/Jakarta
        Asia/Jayapura
        Asia/Jerusalem
        Asia/Kabul
        Asia/Kamchatka
        Asia/Karachi
        Asia/Kashgar
        Asia/Kathmandu
        Asia/Katmandu
        Asia/Khandyga
        Asia/Kolkata
        Asia/Krasnoyarsk
        Asia/Kuala_Lumpur
        Asia/Kuching
        Asia/Kuwait
        Asia/Macao
        Asia/Macau
        Asia/Magadan
        Asia/Makassar
        Asia/Manila
        Asia/Muscat
        Asia/Nicosia
        Asia/Novokuznetsk
        Asia/Novosibirsk
        Asia/Omsk
        Asia/Oral
        Asia/Phnom_Penh
        Asia/Pontianak
        Asia/Pyongyang
        Asia/Qatar
        Asia/Qostanay
        Asia/Qyzylorda
        Asia/Rangoon
        Asia/Riyadh
        Asia/Saigon
        Asia/Sakhalin
        Asia/Samarkand
        Asia/Seoul
        Asia/Shanghai
        Asia/Singapore
        Asia/Srednekolymsk
        Asia/Taipei
        Asia/Tashkent
        Asia/Tbilisi
        Asia/Tehran
        Asia/Tel_Aviv
        Asia/Thimbu
        Asia/Thimphu
        Asia/Tokyo
        Asia/Tomsk
        Asia/Ujung_Pandang
        Asia/Ulaanbaatar
        Asia/Ulan_Bator
        Asia/Urumqi
        Asia/Ust-Nera
        Asia/Vientiane
        Asia/Vladivostok
        Asia/Yakutsk
        Asia/Yangon
        Asia/Yekaterinburg
        Asia/Yerevan
        Atlantic/Azores
        Atlantic/Bermuda
        Atlantic/Canary
        Atlantic/Cape_Verde
        Atlantic/Faeroe
        Atlantic/Faroe
        Atlantic/Jan_Mayen
        Atlantic/Madeira
        Atlantic/Reykjavik
        Atlantic/South_Georgia
        Atlantic/St_Helena
        Atlantic/Stanley
        Australia/ACT
        Australia/Adelaide
        Australia/Brisbane
        Australia/Broken_Hill
        Australia/Canberra
        Australia/Currie
        Australia/Darwin
        Australia/Eucla
        Australia/Hobart
        Australia/LHI
        Australia/Lindeman
        Australia/Lord_Howe
        Australia/Melbourne
        Australia/NSW
        Australia/North
        Australia/Perth
        Australia/Queensland
        Australia/South
        Australia/Sydney
        Australia/Tasmania
        Australia/Victoria
        Australia/West
        Australia/Yancowinna
        Brazil/Acre
        Brazil/DeNoronha
        Brazil/East
        Brazil/West
        CET
        CST6CDT
        Canada/Atlantic
        Canada/Central
        Canada/Eastern
        Canada/Mountain
        Canada/Newfoundland
        Canada/Pacific
        Canada/Saskatchewan
        Canada/Yukon
        Chile/Continental
        Chile/EasterIsland
        Cuba
        EET
        EST5EDT
        Egypt
        Eire
        Etc/GMT
        Etc/GMT+0
        Etc/GMT+1
        Etc/GMT+10
        Etc/GMT+11
        Etc/GMT+12
        Etc/GMT+2
        Etc/GMT+3
        Etc/GMT+4
        Etc/GMT+5
        Etc/GMT+6
        Etc/GMT+7
        Etc/GMT+8
        Etc/GMT+9
        Etc/GMT-0
        Etc/GMT-1
        Etc/GMT-10
        Etc/GMT-11
        Etc/GMT-12
        Etc/GMT-13
        Etc/GMT-14
        Etc/GMT-2
        Etc/GMT-3
        Etc/GMT-4
        Etc/GMT-5
        Etc/GMT-6
        Etc/GMT-7
        Etc/GMT-8
        Etc/GMT-9
        Etc/GMT0
        Etc/Greenwich
        Etc/UCT
        Etc/UTC
        Etc/Universal
        Etc/Zulu
        Europe/Amsterdam
        Europe/Andorra
        Europe/Astrakhan
        Europe/Athens
        Europe/Belfast
        Europe/Belgrade
        Europe/Berlin
        Europe/Bratislava
        Europe/Brussels
        Europe/Bucharest
        Europe/Budapest
        Europe/Busingen
        Europe/Chisinau
        Europe/Copenhagen
        Europe/Dublin
        Europe/Gibraltar
        Europe/Guernsey
        Europe/Helsinki
        Europe/Isle_of_Man
        Europe/Istanbul
        Europe/Jersey
        Europe/Kaliningrad
        Europe/Kiev
        Europe/Kirov
        Europe/Kyiv
        Europe/Lisbon
        Europe/Ljubljana
        Europe/London
        Europe/Luxembourg
        Europe/Madrid
        Europe/Malta
        Europe/Mariehamn
        Europe/Minsk
        Europe/Monaco
        Europe/Moscow
        Europe/Nicosia
        Europe/Oslo
        Europe/Paris
        Europe/Podgorica
        Europe/Prague
        Europe/Riga
        Europe/Rome
        Europe/Samara
        Europe/San_Marino
        Europe/Sarajevo
        Europe/Saratov
        Europe/Simferopol
        Europe/Skopje
        Europe/Sofia
        Europe/Stockholm
        Europe/Tallinn
        Europe/Tirane
        Europe/Tiraspol
        Europe/Ulyanovsk
        Europe/Uzhgorod
        Europe/Vaduz
        Europe/Vatican
        Europe/Vienna
        Europe/Vilnius
        Europe/Volgograd
        Europe/Warsaw
        Europe/Zagreb
        Europe/Zaporozhye
        Europe/Zurich
        GB
        GB-Eire
        GMT
        GMT0
        Greenwich
        Hongkong
        Iceland
        Indian/Antananarivo
        Indian/Chagos
        Indian/Christmas
        Indian/Cocos
        Indian/Comoro
        Indian/Kerguelen
        Indian/Mahe
        Indian/Maldives
        Indian/Mauritius
        Indian/Mayotte
        Indian/Reunion
        Iran
        Israel
        Jamaica
        Japan
        Kwajalein
        Libya
        MET
        MST7MDT
        Mexico/BajaNorte
        Mexico/BajaSur
        Mexico/General
        NZ
        NZ-CHAT
        Navajo
        PRC
        PST8PDT
        Pacific/Apia
        Pacific/Auckland
        Pacific/Bougainville
        Pacific/Chatham
        Pacific/Chuuk
        Pacific/Easter
        Pacific/Efate
        Pacific/Enderbury
        Pacific/Fakaofo
        Pacific/Fiji
        Pacific/Funafuti
        Pacific/Galapagos
        Pacific/Gambier
        Pacific/Guadalcanal
        Pacific/Guam
        Pacific/Honolulu
        Pacific/Johnston
        Pacific/Kanton
        Pacific/Kiritimati
        Pacific/Kosrae
        Pacific/Kwajalein
        Pacific/Majuro
        Pacific/Marquesas
        Pacific/Midway
        Pacific/Nauru
        Pacific/Niue
        Pacific/Norfolk
        Pacific/Noumea
        Pacific/Pago_Pago
        Pacific/Palau
        Pacific/Pitcairn
        Pacific/Pohnpei
        Pacific/Ponape
        Pacific/Port_Moresby
        Pacific/Rarotonga
        Pacific/Saipan
        Pacific/Samoa
        Pacific/Tahiti
        Pacific/Tarawa
        Pacific/Tongatapu
        Pacific/Truk
        Pacific/Wake
        Pacific/Wallis
        Pacific/Yap
        Poland
        Portugal
        ROK
        Singapore
        SystemV/AST4
        SystemV/AST4ADT
        SystemV/CST6
        SystemV/CST6CDT
        SystemV/EST5
        SystemV/EST5EDT
        SystemV/HST10
        SystemV/MST7
        SystemV/MST7MDT
        SystemV/PST8
        SystemV/PST8PDT
        SystemV/YST9
        SystemV/YST9YDT
        Turkey
        UCT
        US/Alaska
        US/Aleutian
        US/Arizona
        US/Central
        US/East-Indiana
        US/Eastern
        US/Hawaii
        US/Indiana-Starke
        US/Michigan
        US/Mountain
        US/Pacific
        US/Samoa
        UTC
        Universal
        W-SU
        WET
        Zulu
        
        Process finished with exit code 0
        
        ```
        
    
    ZoneId의 getAvailableZoneIds 메소드를 호출하면 “Europe/Paris”와 같은 유효한 시간대별 ID를 저장한 컬렉션 인스턴스의 참조 값이 반환된다. 따라서 다음과 같이 코드를 작성하면 유효한 모든 시간대별 ID를 정렬된 상태로 볼 수 있다.
    
    ```java
    ZoneId.getAvailableZoneIds()
          .stream()
          .sorted()
          .forEach(s -> System.out.println(s));
        
    ```
    
    그러나 그 수가 너무 많다. 예제에서 주석이 된 부분처럼 필터링을 해서 원하는 부분만 볼 필요도 있다.
    
- 시간대를 반영한 ZonedDateTime 클래스
    
    LocalDateTime 클래스는 시간대 정보를 가지고 있지 않다. 반면 이번에 소개하는 ZonedDateTime 클래스는 인스턴스 별로 시간대 정보를 지정할 수 있다.
    
    ```java
    import java.time.Duration;
    import java.time.ZoneId;
    import java.time.ZonedDateTime;
    
    class ZonedDateTimeDemo1 {
        public static void main(String[] args) {
            // 이곳의 현재 날짜와 시각
            ZonedDateTime here = ZonedDateTime.now();
            System.out.println(here);
    
            // 동일한 날짜와 시각의 파리
            ZonedDateTime paris = ZonedDateTime.of(
                                   here.toLocalDateTime(), ZoneId.of("Europe/Paris"));
            System.out.println(paris);
    
            // 이곳과 파리의 시차 
            Duration diff = Duration.between(here, paris);
            System.out.println(diff);
        }
    }
    ```
    
    ```java
    2024-03-20T21:00:05.472404+09:00[Asia/Seoul]
    2024-03-20T21:00:05.472404+01:00[Europe/Paris]
    PT8H
    ```
    
    우선 ZonedDateTime 인스턴스를 생성할 때 호출하는 대표적인 메소드 셋은 다음과 같다.
    
    ```java
    public static ZonedDateTime now()
    public static ZonedDateTime of(LocalTime localDateTime, ZoneId zone)
    public static ZonedDateTime of(int year, int month, int dayOfMonth, int hour,
    	int minute, int second, int nanoOfSecond, ZoneId zone)
    ```
    
    위 예제에서는 먼저 now 메소드 호출을 통해서 다음과 같이 ZonedDateTime 인스턴스를 생성하였다.
    
    ```java
    ZonedDateTime here = ZonedDateTime.now();
    ```
    
    이 경우 현재 시스템의 날짜, 시각, 시간대 정보를 갖는 인스턴스가 생성되어 반환된다. 그리고 이를 다음과 같이 출력하면 이에 대한 정보를 확인할 수 있다.
    
    ```java
    System.out.println(here);
    ```
    
    출력 결과는 다음과 같다.
    
    ```java
    2024-03-20T21:00:05.472404+09:00[Asia/Seoul]
    ```
    
    이는 날짜의 2024-03-20, 시각은 15:32:02.97, 시간대는 Asia/Seoul라는 뜻이다. 그리고 중간에 위치한 +09:00은 이 시간대가 UTC보다 9시간이 빠름을 의미한다. 그럼 이어서 다음 문장을 보자.
    
    ```java
    ZonedDateTime paris = ZonedDateTime.of(
                                   here.toLocalDateTime(), ZoneId.of("Europe/Paris"));
    ```
    
    ZonedDateTime의 ToLocalDateTime 메소드가 호출되면 시간대 정보가 생략된, 그러니깐 날짜와 정보만 LocalDateTime 인스턴스에 담아서 반환이 된다. 즉 위의 문장은 앞서 생성한 인스턴스와, 날짜와 시간은 같고 시간대만 Europe/Paris으로 바꾼 ZonedDateTime 인스턴스를 생성하는 문장이다. 그럼 이 인스턴스를 대상으로 출력한 결과를 보자.
    
    ```java
    2024-03-20T21:00:05.472404+01:00[Europe/Paris]
    ```
    
    앞서 생성한 인스턴스와 시간대를 제외한 모든 것이 동일하다. 따라서 이 둘의 시각의 차를 계산해서 출력하면,
    
    ```java
    Duration diff = Duration.between(here, paris);
    System.out.println(diff);
    ```
    
    그 결과로 PT8H가 출력이 된다. 이는 8시간의 차가 있다는 뜻이다. 분명 숫자 상의 시각은 일치하지만 시간대를 고려하면 같은 숫자의 한국이 8시간이 더 빠르다. 이렇듯 ZonedDateTime 인스턴스 대상으로 시각의 차를 계산하면 시간대까지 고려가 된다. 그럼 이번에는 다음 비행시간과 관련이 있는 질문에 답을 하는 예제를 작성해보겠다.
    
    [From 한국 to 프랑스]
    
    - 한국 출발 현지 시간 2017년 12월 9일 14시 30분
    - 파리 도착 현지 시간 2017년 12월 9일 17시 25분
    - 비행에 걸린 시간은?
    
    ```java
    import java.time.Duration;
    import java.time.ZoneId;
    import java.time.LocalDateTime;
    import java.time.ZonedDateTime;
    
    class ZonedDateTimeDemo2 {
        public static void main(String[] args) {
            // 한국 출발 2017-09-09  14:30
            ZonedDateTime departure = ZonedDateTime.of(
                    LocalDateTime.of(2017, 12, 9, 14, 30), ZoneId.of("Asia/Seoul"));
    
            System.out.println("Departure : " + departure);
    
            // 파리 도착 2017-09-09  17:25
            ZonedDateTime arrival = ZonedDateTime.of(
                    LocalDateTime.of(2017, 12, 9, 17, 25), ZoneId.of("Europe/Paris"));
    
            System.out.println("Arrival : " + arrival);
    
            // 비행 시간
            System.out.println("Flight Time : " + 
                    Duration.between(departure, arrival));
        }
    }
    
    ```
    
    ```java
    Departure : 2017-12-09T14:30+09:00[Asia/Seoul]
    Arrival : 2017-12-09T17:25+01:00[Europe/Paris]
    Flight Time : PT10H55M
    ```
    
    위 예제에서는 다음과 같이 of 메소드 호출을 통해서 두 개의 ZonedDateTime 인스턴스를 생성하였다.
    
    그리고 Duration의 beween 메소드 호출을 통해서 비행시간이 10시간 55분임을 확인하였다.
    
- 날짜와 시각 정보의 출력 포맷 지정
    
    날짜와 시간 정보는 보이는 부분이 중요하다. 따라서 프로그램의 내용과 상황에 맞게 날짜와 시각 정보를 출력할 수 있어야 한다. 출력의 포맷 정보는 java.time.format.DateTimeFormatter 인스턴스에 담는다. 그리고 다음 메소드를 호출하면서 이 인스턴스를 인자로 전달하면, 전달된 포맷에 맞게 날짜와 시각 정보가 문자열로 구성되어 반환이 된다.
    
    ```java
    public String format(DateTimeFormatter formatter)
    ```
    
    위의 format 메소드는 LocalDate, LocalTime, LocalDateTime, ZonedDateTime 클래스에 모두 정의되어 있다. 그럼 다음 예제를 보자. 이 예제는 ZonedDateTime을 대상으로 출력 포맷의 지정 방법을 보이지만, format 메소드를 갖는 다른 세 클래스에도 이 방법이 동일하게 적용된다.
    
    ```java
    import java.time.ZoneId;
    import java.time.LocalDateTime;
    import java.time.ZonedDateTime;
    import java.time.format.DateTimeFormatter;
    
    class DateTimeFormatterDemo {
        public static void main(String[] args) {
            ZonedDateTime date = ZonedDateTime.of(
                   LocalDateTime.of(2019, 4, 25, 11, 20), ZoneId.of("Asia/Seoul"));
         
            DateTimeFormatter fm1 = 
                       DateTimeFormatter.ofPattern("yy-M-d");
            DateTimeFormatter fm2 = 
                       DateTimeFormatter.ofPattern("yyyy-MM-d, H:m:s");
            DateTimeFormatter fm3 = 
                       DateTimeFormatter.ofPattern("yyyy-MM-dd, HH:mm:ss  VV");
    
            System.out.println(date.format(fm1));
            System.out.println(date.format(fm2));
            System.out.println(date.format(fm3));
        }
    }
    ```
    
    ```java
    19-4-25
    2019-04-25, 11:20:0
    2019-04-25, 11:20:00  Asia/Seoul
    ```
    
    위 예제의 다음 문장을 보자. 이 문장에서 보이듯이 ofPattern 메소드 호출을 통해서 포맷 정보를 갖는 인스턴스를 생성한다.
    
    ```java
    DateTimeFormatter fm1 = DateTimeFormatter.ofPattern("yy-M-d");
    ```
    
    위의 포맷에서 y, M d는 각각 년, 월, 일의 출력을 의미, 그런데 y가 둘이다. 이는 끝의 두 자리만 출력하라는 의미이다.
    
    ```java
    DateTimeFormatter fm2 = DateTimeFormatter.ofPattern("yyyy-MM-d, H:m:s");
    ```
    
    위의 포맷에서 y가 네 개이므로 연도 전체의 출력을 의미한다. 그리고 M이 두 개이다. 이는 앞에 0을 붙여서 항상 두 자리 출력이 되도록 유지하라는 의미이다. 그리고 H, m, s는 각각 시, 분, 초의 출력을 의미한다. 마지막으로 다음 문장을 보자.
    
    ```java
    DateTimeFormatter fm3 = DateTimeFormatter.ofPattern("yyyy-MM-dd, HH:mm:ss  VV");
    ```
    
    위의 포맷에서는 M, d, H, m, s가 모두 둘 씩 이어져 있다. 따라서 숫자가 하나인 경우 0을 붙여서 두 자리 출력이 유지된다. 그리고 마지막에 있는 VV는 시간대 ID의 출력을 의미하는 것으로 반드시 V둘을 붙여야 한다.
    
    지금까지 설명한 내용이면 우리에게 익숙한 웬만한 출력은 다 만들어 낼 수 있다. 그러나 보다 다양한 형태의 출력이 필요하다면 자바 문서의 DateTimeFormatter 클래스 부분을 참고하기 바란다.