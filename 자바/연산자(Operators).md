## 자바에서 제공하는 이항 연산자들

피연산자가 둘인 연산자를 가리켜 ‘이항 연산자’라 한다. 따라서 + , = 도 이항 연산자에 속한다.

- 자바의 연산자들
    
    ![[operators-image.png]]
    
- 복합 대입 연산자
    
    ```java
    a = a + b
    a = a - b
    a = a * b
    a = a / b
    a = a % b
    ```
    
    ```java
    a += b
    a -= b
    a *= b
    a /= b
    a %= b
    ```
    
    처음의 식과 두번째의 식은 같다.
    
    ```java
    public class Main {
        public static void main(String[] args) {
            short num = 10;
            num = (short)(num + 77L);
            int rate = 3;
            rate = (int)(rate * 3.5);
            System.out.println(num);
            System.out.println(rate);
            
            num = 10;
            num += 77L;
            rate = 3;
            rate *= 3.5;
            System.out.println(num);
            System.out.println(rate);
        }
    }
    ```
    
    위의 결과를 보면
    
    복합 대입 연산자들은 형 변환이 필요가 없다. 복합 대입 연산자를 사용하면 알아서 형 변환을 해준다. 따라서 복합 대입 연산자를 사용하면 명시적인 형 변환을 줄이는 장점을 얻을 수 있다.
    
- 관계 연산자
    
    System.out.pritnln(”7.0 == 7 : “ + (7.0 == 7 ));
    
    위에 등장하는 7.0과 7은 다르다. 그러나 == 연산을 위해 자동 형 변환이 일어난다. 그러므로 true이 된다.
    
- 논리 연산자의 사용 시 주의 할 점: Short-Circuit Evaluation
    
    연산의 특성 중에 Short-Circuit-Evaluation이라느 것이 있다. 이것에 대한 간단한 소개는 다음과 같다.
    
    “연산의 효율 및 속도를 높이기 위해서 불필요한 연산을 생략하는 행위”
    
    ```java
    result = ((num1 += 10) < 0) && ((num2 += 10) > 0);
    result = ((num1 += 10) > 0) || ((num2 += 10) > 0);
    ```
    
    위 예저는 num1, num2의 값을 10씩 증가시키는 연산이 각각 포함되어있다.
    
    따라서 결과의 값이 10, 10이 되어야 한다.(num1, num2은 0이다.) 하지만 실행결과는 그렇지 않다.
    
    && 연산자의 경우는 왼편이 flase이면 오른편을 생략하기 때문이다. 그리고 || 연산자의 경우는 왼편이 ture이면 오른편을 생략한다.
    
    이를 정리하면 다음과 같다.
    
    - &&의 왼쪽 피연산자가 flase이면, 오른쪽 피연산다는 확인하지 않는다.
    - ||의 왼쪽 피연산자가 true이면, 오른쪽 피연산자는 확인하지 않는다.
    
    SCE는 불필요한 연산을 줄여주니 분명 유용하다. 그러나 예제와 같이 부작용이 발생할 수 있다. 따라서 문장을 구성할 때 하나의 문장에 너무 많은 연산을 포함하지 않은 것이 좋다. 즉 다음과 같이 코드를 나누어서 작성하는것이 좋다.
    
    ```java
    num1 += 10;
    num2 += 10;
    result = (num1 < 10) && (num2 > 0);
    ```
    

## 자바에서 제공하는 단항 연산자들

- 부호 연산자
    
    ```java
    double e1 = 3.5;
    dobule e2 = -e1; // e2에 저장되는 값은 -3.5
    ```
    
- 증가 및 감소 연산자 : Prefix ++, Prefix --
    
    ```java
    int num = 7;
    System.out.println(++num);
    System.out.println(++num);
    System.out.println(num);
    ```
    
    ```
    8
    9
    9
    ```
    
- 증가 및 감소 연산자: Postfix++, Postfix --
    
    ```java
    int num = 5;
    System.out.println((num++) + " ");
    System.out.println((num++) + " ");
    System.out.println(num + "\\n");
    
    System.out.println((num--) + " ");
    System.out.println((num--) + " ");
    System.out.println(num);
    ```
    
    ```java
    5 6 7
    7 6 5
    ```
    
    Postfix --, ++의 연산으로 인한 값의 증가 및 감소는 연산이 진행된 문장이 아닌, 그 다음 문장으로 넘어가야 반영이된다.
    

## 비트를 대상으로 하는 연산자들

- 비트 연산자의 이해
    
    |&|비트 단위로 AND|
    |---|---|
    |||
    |^|비트 단위로 XOR|
    |~|비트 단위로 모든 비트를 반전시켜서 얻은 결과를 반환|
    
    - 비트 연산자는 각각의 비트를 대상으로 연산을 진행한다.
    - 그리고 각 비트는 대상으로 진행된 연산 결과를 묶어서 하나의 연산 결과를 반환한다.
- 비트 쉬프트 연산자: <<, >>, >>>
    
    비트 쉬프트 연산자는 피연산자의 비트 열을 왼쪽 또는 오른쪽으로 이동시킨 결과를 반환하는 연산자이다. 이 연산자도 피 연산자가 두 개의 피연산자가 필요한 이항 연산자이면 모두 정수이여야 한다.
    
    | << | 피연산자의 비트열을 왼쪽으로 이동 이동에 따른 빈 공간은 0으로 채움 | | --- | --- | | >> | 피연산자의 비트열을 오른쪽으로 이동 이동에 따른 빈 공간은 음수의 경우 , 양수의 경우 0으로 채움 | | >>> | 피연산의 비트 열을 오른쪽으로 이동 이동에 따른 빈 공간은 0으로 채움 |
    
    왼쪽으로 밀어 넣은 << 비트 연산자들은 값이 두배 늘어난다.
    
    오른쪽으로 밀어 넣은 >> 비트 연산자들은 값이 반으로 줄어든다.
    
    음수 -4를 2의 보수하는 과정은 1을 먼저 빼고 1의 보수를 해야한다. 반대인 경우는 1의 보수를 한 경우 1을 더해야 한다.